# File -
0000			;**************************************************************************** 
0000			; 
0000			;    Z80 Retro! BIOS  
0000			; 
0000			;    Copyright (C) 2021,2022 John Winans 
0000			; 
0000			;    This library is free software; you can redistribute it and/or 
0000			;    modify it under the terms of the GNU Lesser General Public 
0000			;    License as published by the Free Software Foundation; either 
0000			;    version 2.1 of the License, or (at your option) any later version. 
0000			; 
0000			;    This library is distributed in the hope that it will be useful, 
0000			;    but WITHOUT ANY WARRANTY; without even the implied warranty of 
0000			;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
0000			;    Lesser General Public License for more details. 
0000			; 
0000			;    You should have received a copy of the GNU Lesser General Public 
0000			;    License along with this library; if not, write to the Free Software 
0000			;    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 
0000			;    USA 
0000			; 
0000			; 
0000			;**************************************************************************** 
0000			 
0000			.low_bank:	equ	0x0e	; The RAM BANK to use for the bottom 32K 
0000			 
0000			host_sel_dsk_port:	equ	0xF4 
0000			host_sd_cmd_port:       equ 	0xF5 
0000			host_conout_port:       equ     0xFE 
0000			host_conin_port:        equ     0xFE 
0000			host_concmd_port:       equ     0xFF 
0000			host_const_port:        equ     0xFF 
0000			 
0000			host_cls_cmd:           equ     0xFF 
0000			 
0000			host_read_block_cmd:    equ 	0x10 
0000			host_write_block_cmd:   equ 	0x11 
0000			 
0000			;########################################################################## 
0000			; set .debug to: 
0000			;    0 = no debug output 
0000			;    1 = print messages from new code under development 
0000			;    2 = print all the above plus the primairy 'normal' debug messages 
0000			;    3 = print all the above plus verbose 'noisy' debug messages 
0000			;########################################################################## 
0000			.debug:		equ	0 
0000			 
0000			; Define the memory size to be used for the CP/M configuration 
0000			MEM:    equ 60 
0000			 
0000			; The CPM origin will be at: (MEM-7)*1024 
0000			; This screwy convention is due to the way that that the CP/M origin is defined. 
0000			CPM_BASE: equ	(MEM-7)*1024 
0000			 
0000			LOAD_BASE: equ	0xc000		; where the boot loader reads the image from the SD card 
0000			 
0000				org	LOAD_BASE		; Where the boot loader places this code. 
c000			 
c000				; This is the entry point from the boot loader. 
c000 c3 33 ea			jp	.bios_boot 
c003			 
c003				; The 'org' in cpm22.asm does not generate any fill so we must 
c003				; padd memory out to the base location of CP/M 
c003 0xff...			ds	CPM_BASE-$,0xff 
d400			 
d400			;########################################################################## 
d400			; 
d400			; In a traditional system, the CP/M CCP and BDOS is manually copied into 
d400			; place when linking it with the BIOS.   
d400			; 
d400			; In this build we cheat by simply compiling the CP/M source in with the  
d400			; BIOS. 
d400			; 
d400			;########################################################################## 
d400			 
d400			include 'cpm22.asm' 
d400			;**************************************************************  
d400			;*  
d400			;*             C P / M   version   2 . 2  
d400			;*  
d400			;*   Reconstructed from memory image on February 27, 1981  
d400			;*  
d400			;*                by Clark A. Calkins  
d400			;*  
d400			;**************************************************************  
d400			;  
d400			;   Set memory limit here. This is the amount of contigeous  
d400			; ram starting from 0000. CP/M will reside at the end of this space.  
d400			;  
d400			;MEM     EQU     62              ;for a 62k system (TS802 TEST - WORKS OK).  
d400			;  
d400			IOBYTE:  EQU     3               ;i/o definition byte.  
d400			TDRIVE:  EQU     4               ;current drive name and user number.  
d400			ENTRY:   EQU     5               ;entry point for the cp/m bdos.  
d400			TFCB:    EQU     5CH             ;default file control block.  
d400			TBUFF:   EQU     80H             ;i/o buffer and command line storage.  
d400			TBASE:   EQU     100H            ;transiant program storage area.  
d400			;  
d400			;   Set control character equates.  
d400			;  
d400			CNTRLC:  EQU     3               ;control-c  
d400			CNTRLE:  EQU     05H             ;control-e  
d400			BS:      EQU     08H             ;backspace  
d400			TAB:     EQU     09H             ;tab  
d400			LF:      EQU     0AH             ;line feed  
d400			FF:      EQU     0CH             ;form feed  
d400			CR:      EQU     0DH             ;carriage return  
d400			CNTRLP:  EQU     10H             ;control-p  
d400			CNTRLR:  EQU     12H             ;control-r  
d400			CNTRLS:  EQU     13H             ;control-s  
d400			CNTRLU:  EQU     15H             ;control-u  
d400			CNTRLX:  EQU     18H             ;control-x  
d400			CNTRLZ:  EQU     1AH             ;control-z (end-of-file mark)  
d400			DEL:     EQU     7FH             ;rubout  
d400			;  
d400			;   Set origin for CP/M  
d400			;  
d400			        ORG     (MEM-7)*1024  
d400			;  
d400 c3 5c d7		CBASE:  JP      COMMAND         ;execute command processor (ccp).  
d403 c3 58 d7		        JP      CLEARBUF        ;entry to empty input buffer before starting ccp.  
d406			  
d406			;  
d406			;   Standard cp/m ccp input buffer. Format is (max length),  
d406			; (actual length), (char #1), (char #2), (char #3), etc.  
d406			;  
d406 7f			INBUFF: DEFB    127             ;length of input buffer.  
d407 00			        DEFB    0               ;current length of contents.  
d408 ..			        DEFB    'Copyright'  
d411 ..			        DEFB    ' 1979 (c) by Digital Research      '  
d434 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00	        DEFB    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0  
d44b 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00	        DEFB    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0  
d462 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00	        DEFB    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0  
d479 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00	        DEFB    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0  
d488 08 d4		INPOINT:DEFW    INBUFF+2        ;input line pointer  
d48a 00 00		NAMEPNT:DEFW    0               ;input line pointer used for error message. Points to  
d48c			;                       ;start of name in error.  
d48c			;  
d48c			;   Routine to print (A) on the console. All registers used.  
d48c			;  
d48c 5f			PRINT:  LD      E,A             ;setup bdos call.  
d48d 0e 02		        LD      C,2  
d48f c3 05 00		        JP      ENTRY  
d492			;  
d492			;   Routine to print (A) on the console and to save (BC).  
d492			;  
d492 c5			PRINTB: PUSH    BC  
d493 cd 8c d4		        CALL    PRINT  
d496 c1			        POP     BC  
d497 c9			        RET       
d498			;  
d498			;   Routine to send a carriage return, line feed combination  
d498			; to the console.  
d498			;  
d498 3e 0d		CRLF:   LD      A,CR  
d49a cd 92 d4		        CALL    PRINTB  
d49d 3e 0a		        LD      A,LF  
d49f c3 92 d4		        JP      PRINTB  
d4a2			;  
d4a2			;   Routine to send one space to the console and save (BC).  
d4a2			;  
d4a2 3e 20		SPACE:  LD      A,' '  
d4a4 c3 92 d4		        JP      PRINTB  
d4a7			;  
d4a7			;   Routine to print character string pointed to be (BC) on the  
d4a7			; console. It must terminate with a null byte.  
d4a7			;  
d4a7 c5			PLINE:  PUSH    BC  
d4a8 cd 98 d4		        CALL    CRLF  
d4ab e1			        POP     HL  
d4ac 7e			PLINE2: LD      A,(HL)  
d4ad b7			        OR      A  
d4ae c8			        RET     Z  
d4af 23			        INC     HL  
d4b0 e5			        PUSH    HL  
d4b1 cd 8c d4		        CALL    PRINT  
d4b4 e1			        POP     HL  
d4b5 c3 ac d4		        JP      PLINE2  
d4b8			;  
d4b8			;   Routine to reset the disk system.  
d4b8			;  
d4b8 0e 0d		RESDSK: LD      C,13  
d4ba c3 05 00		        JP      ENTRY  
d4bd			;  
d4bd			;   Routine to select disk (A).  
d4bd			;  
d4bd 5f			DSKSEL: LD      E,A  
d4be 0e 0e		        LD      C,14  
d4c0 c3 05 00		        JP      ENTRY  
d4c3			;  
d4c3			;   Routine to call bdos and save the return code. The zero  
d4c3			; flag is set on a return of 0ffh.  
d4c3			;  
d4c3 cd 05 00		ENTRY1: CALL    ENTRY  
d4c6 32 ee db		        LD      (RTNCODE),A     ;save return code.  
d4c9 3c			        INC     A               ;set zero if 0ffh returned.  
d4ca c9			        RET       
d4cb			;  
d4cb			;   Routine to open a file. (DE) must point to the FCB.  
d4cb			;  
d4cb 0e 0f		OPEN:   LD      C,15  
d4cd c3 c3 d4		        JP      ENTRY1  
d4d0			;  
d4d0			;   Routine to open file at (FCB).  
d4d0			;  
d4d0 af			OPENFCB:XOR     A               ;clear the record number byte at fcb+32  
d4d1 32 ed db		        LD      (FCB+32),A  
d4d4 11 cd db		        LD      DE,FCB  
d4d7 c3 cb d4		        JP      OPEN  
d4da			;  
d4da			;   Routine to close a file. (DE) points to FCB.  
d4da			;  
d4da 0e 10		CLOSE:  LD      C,16  
d4dc c3 c3 d4		        JP      ENTRY1  
d4df			;  
d4df			;   Routine to search for the first file with ambigueous name  
d4df			; (DE).  
d4df			;  
d4df 0e 11		SRCHFST:LD      C,17  
d4e1 c3 c3 d4		        JP      ENTRY1  
d4e4			;  
d4e4			;   Search for the next ambigeous file name.  
d4e4			;  
d4e4 0e 12		SRCHNXT:LD      C,18  
d4e6 c3 c3 d4		        JP      ENTRY1  
d4e9			;  
d4e9			;   Search for file at (FCB).  
d4e9			;  
d4e9 11 cd db		SRCHFCB:LD      DE,FCB  
d4ec c3 df d4		        JP      SRCHFST  
d4ef			;  
d4ef			;   Routine to delete a file pointed to by (DE).  
d4ef			;  
d4ef 0e 13		DELETE: LD      C,19  
d4f1 c3 05 00		        JP      ENTRY  
d4f4			;  
d4f4			;   Routine to call the bdos and set the zero flag if a zero  
d4f4			; status is returned.  
d4f4			;  
d4f4 cd 05 00		ENTRY2: CALL    ENTRY  
d4f7 b7			        OR      A               ;set zero flag if appropriate.  
d4f8 c9			        RET       
d4f9			;  
d4f9			;   Routine to read the next record from a sequential file.  
d4f9			; (DE) points to the FCB.  
d4f9			;  
d4f9 0e 14		RDREC:  LD      C,20  
d4fb c3 f4 d4		        JP      ENTRY2  
d4fe			;  
d4fe			;   Routine to read file at (FCB).  
d4fe			;  
d4fe 11 cd db		READFCB:LD      DE,FCB  
d501 c3 f9 d4		        JP      RDREC  
d504			;  
d504			;   Routine to write the next record of a sequential file.  
d504			; (DE) points to the FCB.  
d504			;  
d504 0e 15		WRTREC: LD      C,21  
d506 c3 f4 d4		        JP      ENTRY2  
d509			;  
d509			;   Routine to create the file pointed to by (DE).  
d509			;  
d509 0e 16		CREATE: LD      C,22  
d50b c3 c3 d4		        JP      ENTRY1  
d50e			;  
d50e			;   Routine to rename the file pointed to by (DE). Note that  
d50e			; the new name starts at (DE+16).  
d50e			;  
d50e 0e 17		RENAM:  LD      C,23  
d510 c3 05 00		        JP      ENTRY  
d513			;  
d513			;   Get the current user code.  
d513			;  
d513 1e ff		GETUSR: LD      E,0FFH  
d515			;  
d515			;   Routne to get or set the current user code.  
d515			; If (E) is FF then this is a GET, else it is a SET.  
d515			;  
d515 0e 20		GETSETUC: LD    C,32  
d517 c3 05 00		        JP      ENTRY  
d51a			;  
d51a			;   Routine to set the current drive byte at (TDRIVE).  
d51a			;  
d51a cd 13 d5		SETCDRV:CALL    GETUSR          ;get user number  
d51d 87			        ADD     A,A             ;and shift into the upper 4 bits.  
d51e 87			        ADD     A,A  
d51f 87			        ADD     A,A  
d520 87			        ADD     A,A  
d521 21 ef db		        LD      HL,CDRIVE       ;now add in the current drive number.  
d524 b6			        OR      (HL)  
d525 32 04 00		        LD      (TDRIVE),A      ;and save.  
d528 c9			        RET       
d529			;  
d529			;   Move currently active drive down to (TDRIVE).  
d529			;  
d529 3a ef db		MOVECD: LD      A,(CDRIVE)  
d52c 32 04 00		        LD      (TDRIVE),A  
d52f c9			        RET       
d530			;  
d530			;   Routine to convert (A) into upper case ascii. Only letters  
d530			; are affected.  
d530			;  
d530 fe 61		UPPER:  CP      'a'             ;check for letters in the range of 'a' to 'z'.  
d532 d8			        RET     C  
d533 fe 7b		        CP      '{'  
d535 d0			        RET     NC  
d536 e6 5f		        AND     5FH             ;convert it if found.  
d538 c9			        RET       
d539			;  
d539			;   Routine to get a line of input. We must check to see if the  
d539			; user is in (BATCH) mode. If so, then read the input from file  
d539			; ($$$.SUB). At the end, reset to console input.  
d539			;  
d539 3a ab db		GETINP: LD      A,(BATCH)       ;if =0, then use console input.  
d53c b7			        OR      A  
d53d ca 96 d5		        JP      Z,GETINP1  
d540			;  
d540			;   Use the submit file ($$$.sub) which is prepared by a  
d540			; SUBMIT run. It must be on drive (A) and it will be deleted  
d540			; if and error occures (like eof).  
d540			;  
d540 3a ef db		        LD      A,(CDRIVE)      ;select drive 0 if need be.  
d543 b7			        OR      A  
d544 3e 00		        LD      A,0             ;always use drive A for submit.  
d546 c4 bd d4		        CALL    NZ,DSKSEL       ;select it if required.  
d549 11 ac db		        LD      DE,BATCHFCB  
d54c cd cb d4		        CALL    OPEN            ;look for it.  
d54f ca 96 d5		        JP      Z,GETINP1       ;if not there, use normal input.  
d552 3a bb db		        LD      A,(BATCHFCB+15) ;get last record number+1.  
d555 3d			        DEC     A  
d556 32 cc db		        LD      (BATCHFCB+32),A  
d559 11 ac db		        LD      DE,BATCHFCB  
d55c cd f9 d4		        CALL    RDREC           ;read last record.  
d55f c2 96 d5		        JP      NZ,GETINP1      ;quit on end of file.  
d562			;  
d562			;   Move this record into input buffer.  
d562			;  
d562 11 07 d4		        LD      DE,INBUFF+1  
d565 21 80 00		        LD      HL,TBUFF        ;data was read into buffer here.  
d568 06 80		        LD      B,128           ;all 128 characters may be used.  
d56a cd 42 d8		        CALL    HL2DE           ;(HL) to (DE), (B) bytes.  
d56d 21 ba db		        LD      HL,BATCHFCB+14  
d570 36 00		        LD      (HL),0          ;zero out the 's2' byte.  
d572 23			        INC     HL              ;and decrement the record count.  
d573 35			        DEC     (HL)  
d574 11 ac db		        LD      DE,BATCHFCB     ;close the batch file now.  
d577 cd da d4		        CALL    CLOSE  
d57a ca 96 d5		        JP      Z,GETINP1       ;quit on an error.  
d57d 3a ef db		        LD      A,(CDRIVE)      ;re-select previous drive if need be.  
d580 b7			        OR      A  
d581 c4 bd d4		        CALL    NZ,DSKSEL       ;don't do needless selects.  
d584			;  
d584			;   Print line just read on console.  
d584			;  
d584 21 08 d4		        LD      HL,INBUFF+2  
d587 cd ac d4		        CALL    PLINE2  
d58a cd c2 d5		        CALL    CHKCON          ;check console, quit on a key.  
d58d ca a7 d5		        JP      Z,GETINP2       ;jump if no key is pressed.  
d590			;  
d590			;   Terminate the submit job on any keyboard input. Delete this  
d590			; file such that it is not re-started and jump to normal keyboard  
d590			; input section.  
d590			;  
d590 cd dd d5		        CALL    DELBATCH        ;delete the batch file.  
d593 c3 82 d7		        JP      CMMND1          ;and restart command input.  
d596			;  
d596			;   Get here for normal keyboard input. Delete the submit file  
d596			; incase there was one.  
d596			;  
d596 cd dd d5		GETINP1:CALL    DELBATCH        ;delete file ($$$.sub).  
d599 cd 1a d5		        CALL    SETCDRV         ;reset active disk.  
d59c 0e 0a		        LD      C,10            ;get line from console device.  
d59e 11 06 d4		        LD      DE,INBUFF  
d5a1 cd 05 00		        CALL    ENTRY  
d5a4 cd 29 d5		        CALL    MOVECD          ;reset current drive (again).  
d5a7			;  
d5a7			;   Convert input line to upper case.  
d5a7			;  
d5a7 21 07 d4		GETINP2:LD      HL,INBUFF+1  
d5aa 46			        LD      B,(HL)          ;(B)=character counter.  
d5ab 23			GETINP3:INC     HL  
d5ac 78			        LD      A,B             ;end of the line?  
d5ad b7			        OR      A  
d5ae ca ba d5		        JP      Z,GETINP4  
d5b1 7e			        LD      A,(HL)          ;convert to upper case.  
d5b2 cd 30 d5		        CALL    UPPER  
d5b5 77			        LD      (HL),A  
d5b6 05			        DEC     B               ;adjust character count.  
d5b7 c3 ab d5		        JP      GETINP3  
d5ba 77			GETINP4:LD      (HL),A          ;add trailing null.  
d5bb 21 08 d4		        LD      HL,INBUFF+2  
d5be 22 88 d4		        LD      (INPOINT),HL    ;reset input line pointer.  
d5c1 c9			        RET       
d5c2			;  
d5c2			;   Routine to check the console for a key pressed. The zero  
d5c2			; flag is set is none, else the character is returned in (A).  
d5c2			;  
d5c2 0e 0b		CHKCON: LD      C,11            ;check console.  
d5c4 cd 05 00		        CALL    ENTRY  
d5c7 b7			        OR      A  
d5c8 c8			        RET     Z               ;return if nothing.  
d5c9 0e 01		        LD      C,1             ;else get character.  
d5cb cd 05 00		        CALL    ENTRY  
d5ce b7			        OR      A               ;clear zero flag and return.  
d5cf c9			        RET       
d5d0			;  
d5d0			;   Routine to get the currently active drive number.  
d5d0			;  
d5d0 0e 19		GETDSK: LD      C,25  
d5d2 c3 05 00		        JP      ENTRY  
d5d5			;  
d5d5			;   Set the stabdard dma address.  
d5d5			;  
d5d5 11 80 00		STDDMA: LD      DE,TBUFF  
d5d8			;  
d5d8			;   Routine to set the dma address to (DE).  
d5d8			;  
d5d8 0e 1a		DMASET: LD      C,26  
d5da c3 05 00		        JP      ENTRY  
d5dd			;  
d5dd			;  Delete the batch file created by SUBMIT.  
d5dd			;  
d5dd 21 ab db		DELBATCH: LD    HL,BATCH        ;is batch active?  
d5e0 7e			        LD      A,(HL)  
d5e1 b7			        OR      A  
d5e2 c8			        RET     Z  
d5e3 36 00		        LD      (HL),0          ;yes, de-activate it.  
d5e5 af			        XOR     A  
d5e6 cd bd d4		        CALL    DSKSEL          ;select drive 0 for sure.  
d5e9 11 ac db		        LD      DE,BATCHFCB     ;and delete this file.  
d5ec cd ef d4		        CALL    DELETE  
d5ef 3a ef db		        LD      A,(CDRIVE)      ;reset current drive.  
d5f2 c3 bd d4		        JP      DSKSEL  
d5f5			;  
d5f5			;   Check to two strings at (PATTRN1) and (PATTRN2). They must be  
d5f5			; the same or we halt....  
d5f5			;  
d5f5 11 28 d7		VERIFY: LD      DE,PATTRN1      ;these are the serial number bytes.  
d5f8 21 00 dc		        LD      HL,PATTRN2      ;ditto, but how could they be different?  
d5fb 06 06		        LD      B,6             ;6 bytes each.  
d5fd 1a			VERIFY1:LD      A,(DE)  
d5fe be			        CP      (HL)  
d5ff c2 cf d7		        JP      NZ,HALT         ;jump to halt routine.  
d602 13			        INC     DE  
d603 23			        INC     HL  
d604 05			        DEC     B  
d605 c2 fd d5		        JP      NZ,VERIFY1  
d608 c9			        RET       
d609			;  
d609			;   Print back file name with a '?' to indicate a syntax error.  
d609			;  
d609 cd 98 d4		SYNERR: CALL    CRLF            ;end current line.  
d60c 2a 8a d4		        LD      HL,(NAMEPNT)    ;this points to name in error.  
d60f 7e			SYNERR1:LD      A,(HL)          ;print it until a space or null is found.  
d610 fe 20		        CP      ' '  
d612 ca 22 d6		        JP      Z,SYNERR2  
d615 b7			        OR      A  
d616 ca 22 d6		        JP      Z,SYNERR2  
d619 e5			        PUSH    HL  
d61a cd 8c d4		        CALL    PRINT  
d61d e1			        POP     HL  
d61e 23			        INC     HL  
d61f c3 0f d6		        JP      SYNERR1  
d622 3e 3f		SYNERR2:LD      A,'?'           ;add trailing '?'.  
d624 cd 8c d4		        CALL    PRINT  
d627 cd 98 d4		        CALL    CRLF  
d62a cd dd d5		        CALL    DELBATCH        ;delete any batch file.  
d62d c3 82 d7		        JP      CMMND1          ;and restart from console input.  
d630			;  
d630			;   Check character at (DE) for legal command input. Note that the  
d630			; zero flag is set if the character is a delimiter.  
d630			;  
d630 1a			CHECK:  LD      A,(DE)  
d631 b7			        OR      A  
d632 c8			        RET     Z  
d633 fe 20		        CP      ' '             ;control characters are not legal here.  
d635 da 09 d6		        JP      C,SYNERR  
d638 c8			        RET     Z               ;check for valid delimiter.  
d639 fe 3d		        CP      '='  
d63b c8			        RET     Z  
d63c fe 5f		        CP      '_'  
d63e c8			        RET     Z  
d63f fe 2e		        CP      '.'  
d641 c8			        RET     Z  
d642 fe 3a		        CP      ':'  
d644 c8			        RET     Z  
d645 fe 3b		        CP      ';'  
d647 c8			        RET     Z  
d648 fe 3c		        CP      '<'  
d64a c8			        RET     Z  
d64b fe 3e		        CP      '>'  
d64d c8			        RET     Z  
d64e c9			        RET       
d64f			;  
d64f			;   Get the next non-blank character from (DE).  
d64f			;  
d64f 1a			NONBLANK: LD    A,(DE)  
d650 b7			        OR      A               ;string ends with a null.  
d651 c8			        RET     Z  
d652 fe 20		        CP      ' '  
d654 c0			        RET     NZ  
d655 13			        INC     DE  
d656 c3 4f d6		        JP      NONBLANK  
d659			;  
d659			;   Add (HL)=(HL)+(A)  
d659			;  
d659 85			ADDHL:  ADD     A,L  
d65a 6f			        LD      L,A  
d65b d0			        RET     NC              ;take care of any carry.  
d65c 24			        INC     H  
d65d c9			        RET       
d65e			;  
d65e			;   Convert the first name in (FCB).  
d65e			;  
d65e 3e 00		CONVFST:LD      A,0  
d660			;  
d660			;   Format a file name (convert * to '?', etc.). On return,  
d660			; (A)=0 is an unambigeous name was specified. Enter with (A) equal to  
d660			; the position within the fcb for the name (either 0 or 16).  
d660			;  
d660 21 cd db		CONVERT:LD      HL,FCB  
d663 cd 59 d6		        CALL    ADDHL  
d666 e5			        PUSH    HL  
d667 e5			        PUSH    HL  
d668 af			        XOR     A  
d669 32 f0 db		        LD      (CHGDRV),A      ;initialize drive change flag.  
d66c 2a 88 d4		        LD      HL,(INPOINT)    ;set (HL) as pointer into input line.  
d66f eb			        EX      DE,HL  
d670 cd 4f d6		        CALL    NONBLANK        ;get next non-blank character.  
d673 eb			        EX      DE,HL  
d674 22 8a d4		        LD      (NAMEPNT),HL    ;save pointer here for any error message.  
d677 eb			        EX      DE,HL  
d678 e1			        POP     HL  
d679 1a			        LD      A,(DE)          ;get first character.  
d67a b7			        OR      A  
d67b ca 89 d6		        JP      Z,CONVRT1  
d67e de 40		        SBC     A,'A'-1         ;might be a drive name, convert to binary.  
d680 47			        LD      B,A             ;and save.  
d681 13			        INC     DE              ;check next character for a ':'.  
d682 1a			        LD      A,(DE)  
d683 fe 3a		        CP      ':'  
d685 ca 90 d6		        JP      Z,CONVRT2  
d688 1b			        DEC     DE              ;nope, move pointer back to the start of the line.  
d689 3a ef db		CONVRT1:LD      A,(CDRIVE)  
d68c 77			        LD      (HL),A  
d68d c3 96 d6		        JP      CONVRT3  
d690 78			CONVRT2:LD      A,B  
d691 32 f0 db		        LD      (CHGDRV),A      ;set change in drives flag.  
d694 70			        LD      (HL),B  
d695 13			        INC     DE  
d696			;  
d696			;   Convert the basic file name.  
d696			;  
d696 06 08		CONVRT3:LD      B,08H  
d698 cd 30 d6		CONVRT4:CALL    CHECK  
d69b ca b9 d6		        JP      Z,CONVRT8  
d69e 23			        INC     HL  
d69f fe 2a		        CP      '*'             ;note that an '*' will fill the remaining  
d6a1 c2 a9 d6		        JP      NZ,CONVRT5      ;field with '?'.  
d6a4 36 3f		        LD      (HL),'?'  
d6a6 c3 ab d6		        JP      CONVRT6  
d6a9 77			CONVRT5:LD      (HL),A  
d6aa 13			        INC     DE  
d6ab 05			CONVRT6:DEC     B  
d6ac c2 98 d6		        JP      NZ,CONVRT4  
d6af cd 30 d6		CONVRT7:CALL    CHECK           ;get next delimiter.  
d6b2 ca c0 d6		        JP      Z,GETEXT  
d6b5 13			        INC     DE  
d6b6 c3 af d6		        JP      CONVRT7  
d6b9 23			CONVRT8:INC     HL              ;blank fill the file name.  
d6ba 36 20		        LD      (HL),' '  
d6bc 05			        DEC     B  
d6bd c2 b9 d6		        JP      NZ,CONVRT8  
d6c0			;  
d6c0			;   Get the extension and convert it.  
d6c0			;  
d6c0 06 03		GETEXT: LD      B,03H  
d6c2 fe 2e		        CP      '.'  
d6c4 c2 e9 d6		        JP      NZ,GETEXT5  
d6c7 13			        INC     DE  
d6c8 cd 30 d6		GETEXT1:CALL    CHECK  
d6cb ca e9 d6		        JP      Z,GETEXT5  
d6ce 23			        INC     HL  
d6cf fe 2a		        CP      '*'  
d6d1 c2 d9 d6		        JP      NZ,GETEXT2  
d6d4 36 3f		        LD      (HL),'?'  
d6d6 c3 db d6		        JP      GETEXT3  
d6d9 77			GETEXT2:LD      (HL),A  
d6da 13			        INC     DE  
d6db 05			GETEXT3:DEC     B  
d6dc c2 c8 d6		        JP      NZ,GETEXT1  
d6df cd 30 d6		GETEXT4:CALL    CHECK  
d6e2 ca f0 d6		        JP      Z,GETEXT6  
d6e5 13			        INC     DE  
d6e6 c3 df d6		        JP      GETEXT4  
d6e9 23			GETEXT5:INC     HL  
d6ea 36 20		        LD      (HL),' '  
d6ec 05			        DEC     B  
d6ed c2 e9 d6		        JP      NZ,GETEXT5  
d6f0 06 03		GETEXT6:LD      B,3  
d6f2 23			GETEXT7:INC     HL  
d6f3 36 00		        LD      (HL),0  
d6f5 05			        DEC     B  
d6f6 c2 f2 d6		        JP      NZ,GETEXT7  
d6f9 eb			        EX      DE,HL  
d6fa 22 88 d4		        LD      (INPOINT),HL    ;save input line pointer.  
d6fd e1			        POP     HL  
d6fe			;  
d6fe			;   Check to see if this is an ambigeous file name specification.  
d6fe			; Set the (A) register to non zero if it is.  
d6fe			;  
d6fe 01 0b 00		        LD      BC,11           ;set name length.  
d701 23			GETEXT8:INC     HL  
d702 7e			        LD      A,(HL)  
d703 fe 3f		        CP      '?'             ;any question marks?  
d705 c2 09 d7		        JP      NZ,GETEXT9  
d708 04			        INC     B               ;count them.  
d709 0d			GETEXT9:DEC     C  
d70a c2 01 d7		        JP      NZ,GETEXT8  
d70d 78			        LD      A,B  
d70e b7			        OR      A  
d70f c9			        RET       
d710			;  
d710			;   CP/M command table. Note commands can be either 3 or 4 characters long.  
d710			;  
d710			NUMCMDS: EQU     6               ;number of commands  
d710 ..			CMDTBL: DEFB    'DIR '  
d714 ..			        DEFB    'ERA '  
d718 ..			        DEFB    'TYPE'  
d71c ..			        DEFB    'SAVE'  
d720 ..			        DEFB    'REN '  
d724 ..			        DEFB    'USER'  
d728			;  
d728			;   The following six bytes must agree with those at (PATTRN2)  
d728			; or cp/m will HALT. Why?  
d728			;  
d728 00 16 00 00 00 00	PATTRN1:DEFB    0,22,0,0,0,0    ;(* serial number bytes *).  
d72e			;  
d72e			;   Search the command table for a match with what has just  
d72e			; been entered. If a match is found, then we jump to the  
d72e			; proper section. Else jump to (UNKNOWN).  
d72e			; On return, the (C) register is set to the command number  
d72e			; that matched (or NUMCMDS+1 if no match).  
d72e			;  
d72e 21 10 d7		SEARCH: LD      HL,CMDTBL  
d731 0e 00		        LD      C,0  
d733 79			SEARCH1:LD      A,C  
d734 fe 06		        CP      NUMCMDS         ;this commands exists.  
d736 d0			        RET     NC  
d737 11 ce db		        LD      DE,FCB+1        ;check this one.  
d73a 06 04		        LD      B,4             ;max command length.  
d73c 1a			SEARCH2:LD      A,(DE)  
d73d be			        CP      (HL)  
d73e c2 4f d7		        JP      NZ,SEARCH3      ;not a match.  
d741 13			        INC     DE  
d742 23			        INC     HL  
d743 05			        DEC     B  
d744 c2 3c d7		        JP      NZ,SEARCH2  
d747 1a			        LD      A,(DE)          ;allow a 3 character command to match.  
d748 fe 20		        CP      ' '  
d74a c2 54 d7		        JP      NZ,SEARCH4  
d74d 79			        LD      A,C             ;set return register for this command.  
d74e c9			        RET       
d74f 23			SEARCH3:INC     HL  
d750 05			        DEC     B  
d751 c2 4f d7		        JP      NZ,SEARCH3  
d754 0c			SEARCH4:INC     C  
d755 c3 33 d7		        JP      SEARCH1  
d758			;  
d758			;   Set the input buffer to empty and then start the command  
d758			; processor (ccp).  
d758			;  
d758 af			CLEARBUF: XOR   A  
d759 32 07 d4		        LD      (INBUFF+1),A    ;second byte is actual length.  
d75c			;  
d75c			;**************************************************************  
d75c			;*  
d75c			;*  
d75c			;* C C P  -   C o n s o l e   C o m m a n d   P r o c e s s o r  
d75c			;*  
d75c			;**************************************************************  
d75c			;*  
d75c 31 ab db		COMMAND:LD      SP,CCPSTACK     ;setup stack area.  
d75f c5			        PUSH    BC              ;note that (C) should be equal to:  
d760 79			        LD      A,C             ;(uuuudddd) where 'uuuu' is the user number  
d761 1f			        RRA                     ;and 'dddd' is the drive number.  
d762 1f			        RRA       
d763 1f			        RRA       
d764 1f			        RRA       
d765 e6 0f		        AND     0FH             ;isolate the user number.  
d767 5f			        LD      E,A  
d768 cd 15 d5		        CALL    GETSETUC        ;and set it.  
d76b cd b8 d4		        CALL    RESDSK          ;reset the disk system.  
d76e 32 ab db		        LD      (BATCH),A       ;clear batch mode flag.  
d771 c1			        POP     BC  
d772 79			        LD      A,C  
d773 e6 0f		        AND     0FH             ;isolate the drive number.  
d775 32 ef db		        LD      (CDRIVE),A      ;and save.  
d778 cd bd d4		        CALL    DSKSEL          ;...and select.  
d77b 3a 07 d4		        LD      A,(INBUFF+1)  
d77e b7			        OR      A               ;anything in input buffer already?  
d77f c2 98 d7		        JP      NZ,CMMND2       ;yes, we just process it.  
d782			;  
d782			;   Entry point to get a command line from the console.  
d782			;  
d782 31 ab db		CMMND1: LD      SP,CCPSTACK     ;set stack straight.  
d785 cd 98 d4		        CALL    CRLF            ;start a new line on the screen.  
d788 cd d0 d5		        CALL    GETDSK          ;get current drive.  
d78b c6 61		        ADD     A,'a'  
d78d cd 8c d4		        CALL    PRINT           ;print current drive.  
d790 3e 3e		        LD      A,'>'  
d792 cd 8c d4		        CALL    PRINT           ;and add prompt.  
d795 cd 39 d5		        CALL    GETINP          ;get line from user.  
d798			;  
d798			;   Process command line here.  
d798			;  
d798 11 80 00		CMMND2: LD      DE,TBUFF  
d79b cd d8 d5		        CALL    DMASET          ;set standard dma address.  
d79e cd d0 d5		        CALL    GETDSK  
d7a1 32 ef db		        LD      (CDRIVE),A      ;set current drive.  
d7a4 cd 5e d6		        CALL    CONVFST         ;convert name typed in.  
d7a7 c4 09 d6		        CALL    NZ,SYNERR       ;wild cards are not allowed.  
d7aa 3a f0 db		        LD      A,(CHGDRV)      ;if a change in drives was indicated,  
d7ad b7			        OR      A               ;then treat this as an unknown command  
d7ae c2 a5 da		        JP      NZ,UNKNOWN      ;which gets executed.  
d7b1 cd 2e d7		        CALL    SEARCH          ;else search command table for a match.  
d7b4			;  
d7b4			;   Note that an unknown command returns  
d7b4			; with (A) pointing to the last address  
d7b4			; in our table which is (UNKNOWN).  
d7b4			;  
d7b4 21 c1 d7		        LD      HL,CMDADR       ;now, look thru our address table for command (A).  
d7b7 5f			        LD      E,A             ;set (DE) to command number.  
d7b8 16 00		        LD      D,0  
d7ba 19			        ADD     HL,DE  
d7bb 19			        ADD     HL,DE           ;(HL)=(CMDADR)+2*(command number).  
d7bc 7e			        LD      A,(HL)          ;now pick out this address.  
d7bd 23			        INC     HL  
d7be 66			        LD      H,(HL)  
d7bf 6f			        LD      L,A  
d7c0 e9			        JP      (HL)            ;now execute it.  
d7c1			;  
d7c1			;   CP/M command address table.  
d7c1			;  
d7c1 77 d8 1f d9 5d d9 ad d9	CMDADR: DEFW    DIRECT,ERASE,TYPE,SAVE  
d7c9 10 da 8e da a5 da	        DEFW    RENAME,USER,UNKNOWN  
d7cf			;  
d7cf			;   Halt the system. Reason for this is unknown at present.  
d7cf			;  
d7cf 21 f3 76		HALT:   LD      HL,76F3H        ;'DI HLT' instructions.  
d7d2 22 00 d4		        LD      (CBASE),HL  
d7d5 21 00 d4		        LD      HL,CBASE  
d7d8 e9			        JP      (HL)  
d7d9			;  
d7d9			;   Read error while TYPEing a file.  
d7d9			;  
d7d9 01 df d7		RDERROR:LD      BC,RDERR  
d7dc c3 a7 d4		        JP      PLINE  
d7df .. 00		RDERR:  DEFB    'Read error',0  
d7ea			;  
d7ea			;   Required file was not located.  
d7ea			;  
d7ea 01 f0 d7		NONE:   LD      BC,NOFILE  
d7ed c3 a7 d4		        JP      PLINE  
d7f0 .. 00		NOFILE: DEFB    'No file',0  
d7f8			;  
d7f8			;   Decode a command of the form 'A>filename number{ filename}.  
d7f8			; Note that a drive specifier is not allowed on the first file  
d7f8			; name. On return, the number is in register (A). Any error  
d7f8			; causes 'filename?' to be printed and the command is aborted.  
d7f8			;  
d7f8 cd 5e d6		DECODE: CALL    CONVFST         ;convert filename.  
d7fb 3a f0 db		        LD      A,(CHGDRV)      ;do not allow a drive to be specified.  
d7fe b7			        OR      A  
d7ff c2 09 d6		        JP      NZ,SYNERR  
d802 21 ce db		        LD      HL,FCB+1        ;convert number now.  
d805 01 0b 00		        LD      BC,11           ;(B)=sum register, (C)=max digit count.  
d808 7e			DECODE1:LD      A,(HL)  
d809 fe 20		        CP      ' '             ;a space terminates the numeral.  
d80b ca 33 d8		        JP      Z,DECODE3  
d80e 23			        INC     HL  
d80f d6 30		        SUB     '0'             ;make binary from ascii.  
d811 fe 0a		        CP      10              ;legal digit?  
d813 d2 09 d6		        JP      NC,SYNERR  
d816 57			        LD      D,A             ;yes, save it in (D).  
d817 78			        LD      A,B             ;compute (B)=(B)*10 and check for overflow.  
d818 e6 e0		        AND     0E0H  
d81a c2 09 d6		        JP      NZ,SYNERR  
d81d 78			        LD      A,B  
d81e 07			        RLCA      
d81f 07			        RLCA      
d820 07			        RLCA                    ;(A)=(B)*8  
d821 80			        ADD     A,B             ;.......*9  
d822 da 09 d6		        JP      C,SYNERR  
d825 80			        ADD     A,B             ;.......*10  
d826 da 09 d6		        JP      C,SYNERR  
d829 82			        ADD     A,D             ;add in new digit now.  
d82a da 09 d6		DECODE2:JP      C,SYNERR  
d82d 47			        LD      B,A             ;and save result.  
d82e 0d			        DEC     C               ;only look at 11 digits.  
d82f c2 08 d8		        JP      NZ,DECODE1  
d832 c9			        RET       
d833 7e			DECODE3:LD      A,(HL)          ;spaces must follow (why?).  
d834 fe 20		        CP      ' '  
d836 c2 09 d6		        JP      NZ,SYNERR  
d839 23			        INC     HL  
d83a 0d			DECODE4:DEC     C  
d83b c2 33 d8		        JP      NZ,DECODE3  
d83e 78			        LD      A,B             ;set (A)=the numeric value entered.  
d83f c9			        RET       
d840			;  
d840			;   Move 3 bytes from (HL) to (DE). Note that there is only  
d840			; one reference to this at (A2D5h).  
d840			;  
d840 06 03		MOVE3:  LD      B,3  
d842			;  
d842			;   Move (B) bytes from (HL) to (DE).  
d842			;  
d842 7e			HL2DE:  LD      A,(HL)  
d843 12			        LD      (DE),A  
d844 23			        INC     HL  
d845 13			        INC     DE  
d846 05			        DEC     B  
d847 c2 42 d8		        JP      NZ,HL2DE  
d84a c9			        RET       
d84b			;  
d84b			;   Compute (HL)=(TBUFF)+(A)+(C) and get the byte that's here.  
d84b			;  
d84b 21 80 00		EXTRACT:LD      HL,TBUFF  
d84e 81			        ADD     A,C  
d84f cd 59 d6		        CALL    ADDHL  
d852 7e			        LD      A,(HL)  
d853 c9			        RET       
d854			;  
d854			;  Check drive specified. If it means a change, then the new  
d854			; drive will be selected. In any case, the drive byte of the  
d854			; fcb will be set to null (means use current drive).  
d854			;  
d854 af			DSELECT:XOR     A               ;null out first byte of fcb.  
d855 32 cd db		        LD      (FCB),A  
d858 3a f0 db		        LD      A,(CHGDRV)      ;a drive change indicated?  
d85b b7			        OR      A  
d85c c8			        RET     Z  
d85d 3d			        DEC     A               ;yes, is it the same as the current drive?  
d85e 21 ef db		        LD      HL,CDRIVE  
d861 be			        CP      (HL)  
d862 c8			        RET     Z  
d863 c3 bd d4		        JP      DSKSEL          ;no. Select it then.  
d866			;  
d866			;   Check the drive selection and reset it to the previous  
d866			; drive if it was changed for the preceeding command.  
d866			;  
d866 3a f0 db		RESETDR:LD      A,(CHGDRV)      ;drive change indicated?  
d869 b7			        OR      A  
d86a c8			        RET     Z  
d86b 3d			        DEC     A               ;yes, was it a different drive?  
d86c 21 ef db		        LD      HL,CDRIVE  
d86f be			        CP      (HL)  
d870 c8			        RET     Z  
d871 3a ef db		        LD      A,(CDRIVE)      ;yes, re-select our old drive.  
d874 c3 bd d4		        JP      DSKSEL  
d877			;  
d877			;**************************************************************  
d877			;*  
d877			;*           D I R E C T O R Y   C O M M A N D  
d877			;*  
d877			;**************************************************************  
d877			;  
d877 cd 5e d6		DIRECT: CALL    CONVFST         ;convert file name.  
d87a cd 54 d8		        CALL    DSELECT         ;select indicated drive.  
d87d 21 ce db		        LD      HL,FCB+1        ;was any file indicated?  
d880 7e			        LD      A,(HL)  
d881 fe 20		        CP      ' '  
d883 c2 8f d8		        JP      NZ,DIRECT2  
d886 06 0b		        LD      B,11            ;no. Fill field with '?' - same as *.*.  
d888 36 3f		DIRECT1:LD      (HL),'?'  
d88a 23			        INC     HL  
d88b 05			        DEC     B  
d88c c2 88 d8		        JP      NZ,DIRECT1  
d88f 1e 00		DIRECT2:LD      E,0             ;set initial cursor position.  
d891 d5			        PUSH    DE  
d892 cd e9 d4		        CALL    SRCHFCB         ;get first file name.  
d895 cc ea d7		        CALL    Z,NONE          ;none found at all?  
d898 ca 1b d9		DIRECT3:JP      Z,DIRECT9       ;terminate if no more names.  
d89b 3a ee db		        LD      A,(RTNCODE)     ;get file's position in segment (0-3).  
d89e 0f			        RRCA      
d89f 0f			        RRCA      
d8a0 0f			        RRCA      
d8a1 e6 60		        AND     60H             ;(A)=position*32  
d8a3 4f			        LD      C,A  
d8a4 3e 0a		        LD      A,10  
d8a6 cd 4b d8		        CALL    EXTRACT         ;extract the tenth entry in fcb.  
d8a9 17			        RLA                     ;check system file status bit.  
d8aa da 0f d9		        JP      C,DIRECT8       ;we don't list them.  
d8ad d1			        POP     DE  
d8ae 7b			        LD      A,E             ;bump name count.  
d8af 1c			        INC     E  
d8b0 d5			        PUSH    DE  
d8b1 e6 03		        AND     03H             ;at end of line?  
d8b3 f5			        PUSH    AF  
d8b4 c2 cc d8		        JP      NZ,DIRECT4  
d8b7 cd 98 d4		        CALL    CRLF            ;yes, end this line and start another.  
d8ba c5			        PUSH    BC  
d8bb cd d0 d5		        CALL    GETDSK          ;start line with ('A:').  
d8be c1			        POP     BC  
d8bf c6 41		        ADD     A,'A'  
d8c1 cd 92 d4		        CALL    PRINTB  
d8c4 3e 3a		        LD      A,':'  
d8c6 cd 92 d4		        CALL    PRINTB  
d8c9 c3 d4 d8		        JP      DIRECT5  
d8cc cd a2 d4		DIRECT4:CALL    SPACE           ;add seperator between file names.  
d8cf 3e 3a		        LD      A,':'  
d8d1 cd 92 d4		        CALL    PRINTB  
d8d4 cd a2 d4		DIRECT5:CALL    SPACE  
d8d7 06 01		        LD      B,1             ;'extract' each file name character at a time.  
d8d9 78			DIRECT6:LD      A,B  
d8da cd 4b d8		        CALL    EXTRACT  
d8dd e6 7f		        AND     7FH             ;strip bit 7 (status bit).  
d8df fe 20		        CP      ' '             ;are we at the end of the name?  
d8e1 c2 f9 d8		        JP      NZ,DRECT65  
d8e4 f1			        POP     AF              ;yes, don't print spaces at the end of a line.  
d8e5 f5			        PUSH    AF  
d8e6 fe 03		        CP      3  
d8e8 c2 f7 d8		        JP      NZ,DRECT63  
d8eb 3e 09		        LD      A,9             ;first check for no extension.  
d8ed cd 4b d8		        CALL    EXTRACT  
d8f0 e6 7f		        AND     7FH  
d8f2 fe 20		        CP      ' '  
d8f4 ca 0e d9		        JP      Z,DIRECT7       ;don't print spaces.  
d8f7 3e 20		DRECT63:LD      A,' '           ;else print them.  
d8f9 cd 92 d4		DRECT65:CALL    PRINTB  
d8fc 04			        INC     B               ;bump to next character psoition.  
d8fd 78			        LD      A,B  
d8fe fe 0c		        CP      12              ;end of the name?  
d900 d2 0e d9		        JP      NC,DIRECT7  
d903 fe 09		        CP      9               ;nope, starting extension?  
d905 c2 d9 d8		        JP      NZ,DIRECT6  
d908 cd a2 d4		        CALL    SPACE           ;yes, add seperating space.  
d90b c3 d9 d8		        JP      DIRECT6  
d90e f1			DIRECT7:POP     AF              ;get the next file name.  
d90f cd c2 d5		DIRECT8:CALL    CHKCON          ;first check console, quit on anything.  
d912 c2 1b d9		        JP      NZ,DIRECT9  
d915 cd e4 d4		        CALL    SRCHNXT         ;get next name.  
d918 c3 98 d8		        JP      DIRECT3         ;and continue with our list.  
d91b d1			DIRECT9:POP     DE              ;restore the stack and return to command level.  
d91c c3 86 db		        JP      GETBACK  
d91f			;  
d91f			;**************************************************************  
d91f			;*  
d91f			;*                E R A S E   C O M M A N D  
d91f			;*  
d91f			;**************************************************************  
d91f			;  
d91f cd 5e d6		ERASE:  CALL    CONVFST         ;convert file name.  
d922 fe 0b		        CP      11              ;was '*.*' entered?  
d924 c2 42 d9		        JP      NZ,ERASE1  
d927 01 52 d9		        LD      BC,YESNO        ;yes, ask for confirmation.  
d92a cd a7 d4		        CALL    PLINE  
d92d cd 39 d5		        CALL    GETINP  
d930 21 07 d4		        LD      HL,INBUFF+1  
d933 35			        DEC     (HL)            ;must be exactly 'y'.  
d934 c2 82 d7		        JP      NZ,CMMND1  
d937 23			        INC     HL  
d938 7e			        LD      A,(HL)  
d939 fe 59		        CP      'Y'  
d93b c2 82 d7		        JP      NZ,CMMND1  
d93e 23			        INC     HL  
d93f 22 88 d4		        LD      (INPOINT),HL    ;save input line pointer.  
d942 cd 54 d8		ERASE1: CALL    DSELECT         ;select desired disk.  
d945 11 cd db		        LD      DE,FCB  
d948 cd ef d4		        CALL    DELETE          ;delete the file.  
d94b 3c			        INC     A  
d94c cc ea d7		        CALL    Z,NONE          ;not there?  
d94f c3 86 db		        JP      GETBACK         ;return to command level now.  
d952 .. 00		YESNO:  DEFB    'All (y/n)?',0  
d95d			;  
d95d			;**************************************************************  
d95d			;*  
d95d			;*            T Y P E   C O M M A N D  
d95d			;*  
d95d			;**************************************************************  
d95d			;  
d95d cd 5e d6		TYPE:   CALL    CONVFST         ;convert file name.  
d960 c2 09 d6		        JP      NZ,SYNERR       ;wild cards not allowed.  
d963 cd 54 d8		        CALL    DSELECT         ;select indicated drive.  
d966 cd d0 d4		        CALL    OPENFCB         ;open the file.  
d969 ca a7 d9		        JP      Z,TYPE5         ;not there?  
d96c cd 98 d4		        CALL    CRLF            ;ok, start a new line on the screen.  
d96f 21 f1 db		        LD      HL,NBYTES       ;initialize byte counter.  
d972 36 ff		        LD      (HL),0FFH       ;set to read first sector.  
d974 21 f1 db		TYPE1:  LD      HL,NBYTES  
d977 7e			TYPE2:  LD      A,(HL)          ;have we written the entire sector?  
d978 fe 80		        CP      128  
d97a da 87 d9		        JP      C,TYPE3  
d97d e5			        PUSH    HL              ;yes, read in the next one.  
d97e cd fe d4		        CALL    READFCB  
d981 e1			        POP     HL  
d982 c2 a0 d9		        JP      NZ,TYPE4        ;end or error?  
d985 af			        XOR     A               ;ok, clear byte counter.  
d986 77			        LD      (HL),A  
d987 34			TYPE3:  INC     (HL)            ;count this byte.  
d988 21 80 00		        LD      HL,TBUFF        ;and get the (A)th one from the buffer (TBUFF).  
d98b cd 59 d6		        CALL    ADDHL  
d98e 7e			        LD      A,(HL)  
d98f fe 1a		        CP      CNTRLZ          ;end of file mark?  
d991 ca 86 db		        JP      Z,GETBACK  
d994 cd 8c d4		        CALL    PRINT           ;no, print it.  
d997 cd c2 d5		        CALL    CHKCON          ;check console, quit if anything ready.  
d99a c2 86 db		        JP      NZ,GETBACK  
d99d c3 74 d9		        JP      TYPE1  
d9a0			;  
d9a0			;   Get here on an end of file or read error.  
d9a0			;  
d9a0 3d			TYPE4:  DEC     A               ;read error?  
d9a1 ca 86 db		        JP      Z,GETBACK  
d9a4 cd d9 d7		        CALL    RDERROR         ;yes, print message.  
d9a7 cd 66 d8		TYPE5:  CALL    RESETDR         ;and reset proper drive  
d9aa c3 09 d6		        JP      SYNERR          ;now print file name with problem.  
d9ad			;  
d9ad			;**************************************************************  
d9ad			;*  
d9ad			;*            S A V E   C O M M A N D  
d9ad			;*  
d9ad			;**************************************************************  
d9ad			;  
d9ad cd f8 d7		SAVE:   CALL    DECODE          ;get numeric number that follows SAVE.  
d9b0 f5			        PUSH    AF              ;save number of pages to write.  
d9b1 cd 5e d6		        CALL    CONVFST         ;convert file name.  
d9b4 c2 09 d6		        JP      NZ,SYNERR       ;wild cards not allowed.  
d9b7 cd 54 d8		        CALL    DSELECT         ;select specified drive.  
d9ba 11 cd db		        LD      DE,FCB          ;now delete this file.  
d9bd d5			        PUSH    DE  
d9be cd ef d4		        CALL    DELETE  
d9c1 d1			        POP     DE  
d9c2 cd 09 d5		        CALL    CREATE          ;and create it again.  
d9c5 ca fb d9		        JP      Z,SAVE3         ;can't create?  
d9c8 af			        XOR     A               ;clear record number byte.  
d9c9 32 ed db		        LD      (FCB+32),A  
d9cc f1			        POP     AF              ;convert pages to sectors.  
d9cd 6f			        LD      L,A  
d9ce 26 00		        LD      H,0  
d9d0 29			        ADD     HL,HL           ;(HL)=number of sectors to write.  
d9d1 11 00 01		        LD      DE,TBASE        ;and we start from here.  
d9d4 7c			SAVE1:  LD      A,H             ;done yet?  
d9d5 b5			        OR      L  
d9d6 ca f1 d9		        JP      Z,SAVE2  
d9d9 2b			        DEC     HL              ;nope, count this and compute the start  
d9da e5			        PUSH    HL              ;of the next 128 byte sector.  
d9db 21 80 00		        LD      HL,128  
d9de 19			        ADD     HL,DE  
d9df e5			        PUSH    HL              ;save it and set the transfer address.  
d9e0 cd d8 d5		        CALL    DMASET  
d9e3 11 cd db		        LD      DE,FCB          ;write out this sector now.  
d9e6 cd 04 d5		        CALL    WRTREC  
d9e9 d1			        POP     DE              ;reset (DE) to the start of the last sector.  
d9ea e1			        POP     HL              ;restore sector count.  
d9eb c2 fb d9		        JP      NZ,SAVE3        ;write error?  
d9ee c3 d4 d9		        JP      SAVE1  
d9f1			;  
d9f1			;   Get here after writing all of the file.  
d9f1			;  
d9f1 11 cd db		SAVE2:  LD      DE,FCB          ;now close the file.  
d9f4 cd da d4		        CALL    CLOSE  
d9f7 3c			        INC     A               ;did it close ok?  
d9f8 c2 01 da		        JP      NZ,SAVE4  
d9fb			;  
d9fb			;   Print out error message (no space).  
d9fb			;  
d9fb 01 07 da		SAVE3:  LD      BC,NOSPACE  
d9fe cd a7 d4		        CALL    PLINE  
da01 cd d5 d5		SAVE4:  CALL    STDDMA          ;reset the standard dma address.  
da04 c3 86 db		        JP      GETBACK  
da07 .. 00		NOSPACE:DEFB    'No space',0  
da10			;  
da10			;**************************************************************  
da10			;*  
da10			;*           R E N A M E   C O M M A N D  
da10			;*  
da10			;**************************************************************  
da10			;  
da10 cd 5e d6		RENAME: CALL    CONVFST         ;convert first file name.  
da13 c2 09 d6		        JP      NZ,SYNERR       ;wild cards not allowed.  
da16 3a f0 db		        LD      A,(CHGDRV)      ;remember any change in drives specified.  
da19 f5			        PUSH    AF  
da1a cd 54 d8		        CALL    DSELECT         ;and select this drive.  
da1d cd e9 d4		        CALL    SRCHFCB         ;is this file present?  
da20 c2 79 da		        JP      NZ,RENAME6      ;yes, print error message.  
da23 21 cd db		        LD      HL,FCB          ;yes, move this name into second slot.  
da26 11 dd db		        LD      DE,FCB+16  
da29 06 10		        LD      B,16  
da2b cd 42 d8		        CALL    HL2DE  
da2e 2a 88 d4		        LD      HL,(INPOINT)    ;get input pointer.  
da31 eb			        EX      DE,HL  
da32 cd 4f d6		        CALL    NONBLANK        ;get next non blank character.  
da35 fe 3d		        CP      '='             ;only allow an '=' or '_' seperator.  
da37 ca 3f da		        JP      Z,RENAME1  
da3a fe 5f		        CP      '_'  
da3c c2 73 da		        JP      NZ,RENAME5  
da3f eb			RENAME1:EX      DE,HL  
da40 23			        INC     HL              ;ok, skip seperator.  
da41 22 88 d4		        LD      (INPOINT),HL    ;save input line pointer.  
da44 cd 5e d6		        CALL    CONVFST         ;convert this second file name now.  
da47 c2 73 da		        JP      NZ,RENAME5      ;again, no wild cards.  
da4a f1			        POP     AF              ;if a drive was specified, then it  
da4b 47			        LD      B,A             ;must be the same as before.  
da4c 21 f0 db		        LD      HL,CHGDRV  
da4f 7e			        LD      A,(HL)  
da50 b7			        OR      A  
da51 ca 59 da		        JP      Z,RENAME2  
da54 b8			        CP      B  
da55 70			        LD      (HL),B  
da56 c2 73 da		        JP      NZ,RENAME5      ;they were different, error.  
da59 70			RENAME2:LD      (HL),B          ;       reset as per the first file specification.  
da5a af			        XOR     A  
da5b 32 cd db		        LD      (FCB),A         ;clear the drive byte of the fcb.  
da5e cd e9 d4		RENAME3:CALL    SRCHFCB         ;and go look for second file.  
da61 ca 6d da		        JP      Z,RENAME4       ;doesn't exist?  
da64 11 cd db		        LD      DE,FCB  
da67 cd 0e d5		        CALL    RENAM           ;ok, rename the file.  
da6a c3 86 db		        JP      GETBACK  
da6d			;  
da6d			;   Process rename errors here.  
da6d			;  
da6d cd ea d7		RENAME4:CALL    NONE            ;file not there.  
da70 c3 86 db		        JP      GETBACK  
da73 cd 66 d8		RENAME5:CALL    RESETDR         ;bad command format.  
da76 c3 09 d6		        JP      SYNERR  
da79 01 82 da		RENAME6:LD      BC,EXISTS       ;destination file already exists.  
da7c cd a7 d4		        CALL    PLINE  
da7f c3 86 db		        JP      GETBACK  
da82 .. 00		EXISTS: DEFB    'File exists',0  
da8e			;  
da8e			;**************************************************************  
da8e			;*  
da8e			;*             U S E R   C O M M A N D  
da8e			;*  
da8e			;**************************************************************  
da8e			;  
da8e cd f8 d7		USER:   CALL    DECODE          ;get numeric value following command.  
da91 fe 10		        CP      16              ;legal user number?  
da93 d2 09 d6		        JP      NC,SYNERR  
da96 5f			        LD      E,A             ;yes but is there anything else?  
da97 3a ce db		        LD      A,(FCB+1)  
da9a fe 20		        CP      ' '  
da9c ca 09 d6		        JP      Z,SYNERR        ;yes, that is not allowed.  
da9f cd 15 d5		        CALL    GETSETUC        ;ok, set user code.  
daa2 c3 89 db		        JP      GETBACK1  
daa5			;  
daa5			;**************************************************************  
daa5			;*  
daa5			;*        T R A N S I A N T   P R O G R A M   C O M M A N D  
daa5			;*  
daa5			;**************************************************************  
daa5			;  
daa5 cd f5 d5		UNKNOWN:CALL    VERIFY          ;check for valid system (why?).  
daa8 3a ce db		        LD      A,(FCB+1)       ;anything to execute?  
daab fe 20		        CP      ' '  
daad c2 c4 da		        JP      NZ,UNKWN1  
dab0 3a f0 db		        LD      A,(CHGDRV)      ;nope, only a drive change?  
dab3 b7			        OR      A  
dab4 ca 89 db		        JP      Z,GETBACK1      ;neither???  
dab7 3d			        DEC     A  
dab8 32 ef db		        LD      (CDRIVE),A      ;ok, store new drive.  
dabb cd 29 d5		        CALL    MOVECD          ;set (TDRIVE) also.  
dabe cd bd d4		        CALL    DSKSEL          ;and select this drive.  
dac1 c3 89 db		        JP      GETBACK1        ;then return.  
dac4			;  
dac4			;   Here a file name was typed. Prepare to execute it.  
dac4			;  
dac4 11 d6 db		UNKWN1: LD      DE,FCB+9        ;an extension specified?  
dac7 1a			        LD      A,(DE)  
dac8 fe 20		        CP      ' '  
daca c2 09 d6		        JP      NZ,SYNERR       ;yes, not allowed.  
dacd d5			UNKWN2: PUSH    DE  
dace cd 54 d8		        CALL    DSELECT         ;select specified drive.  
dad1 d1			        POP     DE  
dad2 21 83 db		        LD      HL,COMFILE      ;set the extension to 'COM'.  
dad5 cd 40 d8		        CALL    MOVE3  
dad8 cd d0 d4		        CALL    OPENFCB         ;and open this file.  
dadb ca 6b db		        JP      Z,UNKWN9        ;not present?  
dade			;  
dade			;   Load in the program.  
dade			;  
dade 21 00 01		        LD      HL,TBASE        ;store the program starting here.  
dae1 e5			UNKWN3: PUSH    HL  
dae2 eb			        EX      DE,HL  
dae3 cd d8 d5		        CALL    DMASET          ;set transfer address.  
dae6 11 cd db		        LD      DE,FCB          ;and read the next record.  
dae9 cd f9 d4		        CALL    RDREC  
daec c2 01 db		        JP      NZ,UNKWN4       ;end of file or read error?  
daef e1			        POP     HL              ;nope, bump pointer for next sector.  
daf0 11 80 00		        LD      DE,128  
daf3 19			        ADD     HL,DE  
daf4 11 00 d4		        LD      DE,CBASE        ;enough room for the whole file?  
daf7 7d			        LD      A,L  
daf8 93			        SUB     E  
daf9 7c			        LD      A,H  
dafa 9a			        SBC     A,D  
dafb d2 71 db		        JP      NC,UNKWN0       ;no, it can't fit.  
dafe c3 e1 da		        JP      UNKWN3  
db01			;  
db01			;   Get here after finished reading.  
db01			;  
db01 e1			UNKWN4: POP     HL  
db02 3d			        DEC     A               ;normal end of file?  
db03 c2 71 db		        JP      NZ,UNKWN0  
db06 cd 66 d8		        CALL    RESETDR         ;yes, reset previous drive.  
db09 cd 5e d6		        CALL    CONVFST         ;convert the first file name that follows  
db0c 21 f0 db		        LD      HL,CHGDRV       ;command name.  
db0f e5			        PUSH    HL  
db10 7e			        LD      A,(HL)          ;set drive code in default fcb.  
db11 32 cd db		        LD      (FCB),A  
db14 3e 10		        LD      A,16            ;put second name 16 bytes later.  
db16 cd 60 d6		        CALL    CONVERT         ;convert second file name.  
db19 e1			        POP     HL  
db1a 7e			        LD      A,(HL)          ;and set the drive for this second file.  
db1b 32 dd db		        LD      (FCB+16),A  
db1e af			        XOR     A               ;clear record byte in fcb.  
db1f 32 ed db		        LD      (FCB+32),A  
db22 11 5c 00		        LD      DE,TFCB         ;move it into place at(005Ch).  
db25 21 cd db		        LD      HL,FCB  
db28 06 21		        LD      B,33  
db2a cd 42 d8		        CALL    HL2DE  
db2d 21 08 d4		        LD      HL,INBUFF+2     ;now move the remainder of the input  
db30 7e			UNKWN5: LD      A,(HL)          ;line down to (0080h). Look for a non blank.  
db31 b7			        OR      A               ;or a null.  
db32 ca 3e db		        JP      Z,UNKWN6  
db35 fe 20		        CP      ' '  
db37 ca 3e db		        JP      Z,UNKWN6  
db3a 23			        INC     HL  
db3b c3 30 db		        JP      UNKWN5  
db3e			;  
db3e			;   Do the line move now. It ends in a null byte.  
db3e			;  
db3e 06 00		UNKWN6: LD      B,0             ;keep a character count.  
db40 11 81 00		        LD      DE,TBUFF+1      ;data gets put here.  
db43 7e			UNKWN7: LD      A,(HL)          ;move it now.  
db44 12			        LD      (DE),A  
db45 b7			        OR      A  
db46 ca 4f db		        JP      Z,UNKWN8  
db49 04			        INC     B  
db4a 23			        INC     HL  
db4b 13			        INC     DE  
db4c c3 43 db		        JP      UNKWN7  
db4f 78			UNKWN8: LD      A,B             ;now store the character count.  
db50 32 80 00		        LD      (TBUFF),A  
db53 cd 98 d4		        CALL    CRLF            ;clean up the screen.  
db56 cd d5 d5		        CALL    STDDMA          ;set standard transfer address.  
db59 cd 1a d5		        CALL    SETCDRV         ;reset current drive.  
db5c cd 00 01		        CALL    TBASE           ;and execute the program.  
db5f			;  
db5f			;   Transiant programs return here (or reboot).  
db5f			;  
db5f 31 ab db		        LD      SP,BATCH        ;set stack first off.  
db62 cd 29 d5		        CALL    MOVECD          ;move current drive into place (TDRIVE).  
db65 cd bd d4		        CALL    DSKSEL          ;and reselect it.  
db68 c3 82 d7		        JP      CMMND1          ;back to comand mode.  
db6b			;  
db6b			;   Get here if some error occured.  
db6b			;  
db6b cd 66 d8		UNKWN9: CALL    RESETDR         ;inproper format.  
db6e c3 09 d6		        JP      SYNERR  
db71 01 7a db		UNKWN0: LD      BC,BADLOAD      ;read error or won't fit.  
db74 cd a7 d4		        CALL    PLINE  
db77 c3 86 db		        JP      GETBACK  
db7a .. 00		BADLOAD:DEFB    'Bad load',0  
db83 ..			COMFILE:DEFB    'COM'           ;command file extension.  
db86			;  
db86			;   Get here to return to command level. We will reset the  
db86			; previous active drive and then either return to command  
db86			; level directly or print error message and then return.  
db86			;  
db86 cd 66 d8		GETBACK:CALL    RESETDR         ;reset previous drive.  
db89 cd 5e d6		GETBACK1: CALL  CONVFST         ;convert first name in (FCB).  
db8c 3a ce db		        LD      A,(FCB+1)       ;if this was just a drive change request,  
db8f d6 20		        SUB     ' '             ;make sure it was valid.  
db91 21 f0 db		        LD      HL,CHGDRV  
db94 b6			        OR      (HL)  
db95 c2 09 d6		        JP      NZ,SYNERR  
db98 c3 82 d7		        JP      CMMND1          ;ok, return to command level.  
db9b			;  
db9b			;   ccp stack area.  
db9b			;  
db9b 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00	        DEFB    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0  
dbab			CCPSTACK: EQU    $       ;end of ccp stack area.  
dbab			;  
dbab			;   Batch (or SUBMIT) processing information storage.  
dbab			;  
dbab 00			BATCH:  DEFB    0               ;batch mode flag (0=not active).  
dbac 00 .. 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00	BATCHFCB: DEFB  0,'$$$     SUB',0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0  
dbcd			;  
dbcd			;   File control block setup by the CCP.  
dbcd			;  
dbcd 00 .. 00 00 00 00 00 .. 00 00 00 00 00	FCB:    DEFB    0,'           ',0,0,0,0,0,'           ',0,0,0,0,0  
dbee 00			RTNCODE:DEFB    0               ;status returned from bdos call.  
dbef 00			CDRIVE: DEFB    0               ;currently active drive.  
dbf0 00			CHGDRV: DEFB    0               ;change in drives flag (0=no change).  
dbf1 00 00		NBYTES: DEFW    0               ;byte counter used by TYPE.  
dbf3			;  
dbf3			;   Room for expansion?  
dbf3			;  
dbf3 00 00 00 00 00 00 00 00 00 00 00 00 00	        DEFB    0,0,0,0,0,0,0,0,0,0,0,0,0  
dc00			;  
dc00			;   Note that the following six bytes must match those at  
dc00			; (PATTRN1) or cp/m will HALT. Why?  
dc00			;  
dc00 00 16 00 00 00 00	PATTRN2:DEFB    0,22,0,0,0,0    ;(* serial number bytes *).  
dc06			;  
dc06			;**************************************************************  
dc06			;*  
dc06			;*                    B D O S   E N T R Y  
dc06			;*  
dc06			;**************************************************************  
dc06			;  
dc06 c3 11 dc		FBASE:  JP      FBASE1  
dc09			;  
dc09			;   Bdos error table.  
dc09			;  
dc09 99 dc		BADSCTR:DEFW    ERROR1          ;bad sector on read or write.  
dc0b a5 dc		BADSLCT:DEFW    ERROR2          ;bad disk select.  
dc0d ab dc		RODISK: DEFW    ERROR3          ;disk is read only.  
dc0f b1 dc		ROFILE: DEFW    ERROR4          ;file is read only.  
dc11			;  
dc11			;   Entry into bdos. (DE) or (E) are the parameters passed. The  
dc11			; function number desired is in register (C).  
dc11			;  
dc11 eb			FBASE1: EX      DE,HL           ;save the (DE) parameters.  
dc12 22 43 df		        LD      (PARAMS),HL  
dc15 eb			        EX      DE,HL  
dc16 7b			        LD      A,E             ;and save register (E) in particular.  
dc17 32 d6 e9		        LD      (EPARAM),A  
dc1a 21 00 00		        LD      HL,0  
dc1d 22 45 df		        LD      (STATUS),HL     ;clear return status.  
dc20 39			        ADD     HL,SP  
dc21 22 0f df		        LD      (USRSTACK),HL   ;save users stack pointer.  
dc24 31 41 df		        LD      SP,STKAREA      ;and set our own.  
dc27 af			        XOR     A               ;clear auto select storage space.  
dc28 32 e0 e9		        LD      (AUTOFLAG),A  
dc2b 32 de e9		        LD      (AUTO),A  
dc2e 21 74 e9		        LD      HL,GOBACK       ;set return address.  
dc31 e5			        PUSH    HL  
dc32 79			        LD      A,C             ;get function number.  
dc33 fe 29		        CP      NFUNCTS         ;valid function number?  
dc35 d0			        RET     NC  
dc36 4b			        LD      C,E             ;keep single register function here.  
dc37 21 47 dc		        LD      HL,FUNCTNS      ;now look thru the function table.  
dc3a 5f			        LD      E,A  
dc3b 16 00		        LD      D,0             ;(DE)=function number.  
dc3d 19			        ADD     HL,DE  
dc3e 19			        ADD     HL,DE           ;(HL)=(start of table)+2*(function number).  
dc3f 5e			        LD      E,(HL)  
dc40 23			        INC     HL  
dc41 56			        LD      D,(HL)          ;now (DE)=address for this function.  
dc42 2a 43 df		        LD      HL,(PARAMS)     ;retrieve parameters.  
dc45 eb			        EX      DE,HL           ;now (DE) has the original parameters.  
dc46 e9			        JP      (HL)            ;execute desired function.  
dc47			;  
dc47			;   BDOS function jump table.  
dc47			;  
dc47			NFUNCTS: EQU     41              ;number of functions in followin table.  
dc47			;  
dc47 03 ea c8 de 90 dd ce de 12 ea 0f ea d4 de ed de	FUNCTNS:DEFW    WBOOT,GETCON,OUTCON,GETRDR,PUNCH,LIST,DIRCIO,GETIOB  
dc57 f3 de f8 de e1 dd fe de 7e e8 83 e8 45 e8 9c e8	        DEFW    SETIOB,PRTSTR,RDBUFF,GETCSTS,GETVER,RSTDSK,SETDSK,OPENFIL  
dc67 a5 e8 ab e8 c8 e8 d7 e8 e0 e8 e6 e8 ec e8	        DEFW    CLOSEFIL,GETFST,GETNXT,DELFILE,READSEQ,WRTSEQ,FCREATE  
dc75 f5 e8 fe e8 04 e9 0a e9 11 e9 2c e1 17 e9 1d e9	        DEFW    RENFILE,GETLOG,GETCRNT,PUTDMA,GETALOC,WRTPRTD,GETROV,SETATTR  
dc85 26 e9 2d e9 41 e9 47 e9 4d e9 0e e8 53 e9 04 df	        DEFW    GETPARM,GETUSER,RDRANDOM,WTRANDOM,FILESIZE,SETRAN,LOGOFF,RTN  
dc95 04 df 9b e9	        DEFW    RTN,WTSPECL  
dc99			;  
dc99			;   Bdos error message section.  
dc99			;  
dc99 21 ca dc		ERROR1: LD      HL,BADSEC       ;bad sector message.  
dc9c cd e5 dc		        CALL    PRTERR          ;print it and get a 1 char responce.  
dc9f fe 03		        CP      CNTRLC          ;re-boot request (control-c)?  
dca1 ca 00 00		        JP      Z,0             ;yes.  
dca4 c9			        RET                     ;no, return to retry i/o function.  
dca5			;  
dca5 21 d5 dc		ERROR2: LD      HL,BADSEL       ;bad drive selected.  
dca8 c3 b4 dc		        JP      ERROR5  
dcab			;  
dcab 21 e1 dc		ERROR3: LD      HL,DISKRO       ;disk is read only.  
dcae c3 b4 dc		        JP      ERROR5  
dcb1			;  
dcb1 21 dc dc		ERROR4: LD      HL,FILERO       ;file is read only.  
dcb4			;  
dcb4 cd e5 dc		ERROR5: CALL    PRTERR  
dcb7 c3 00 00		        JP      0               ;always reboot on these errors.  
dcba			;  
dcba ..			BDOSERR:DEFB    'Bdos Err On '  
dcc6 ..			BDOSDRV:DEFB    ' : $'  
dcca ..			BADSEC: DEFB    'Bad Sector$'  
dcd5 ..			BADSEL: DEFB    'Select$'  
dcdc ..			FILERO: DEFB    'File '  
dce1 ..			DISKRO: DEFB    'R/O$'  
dce5			;  
dce5			;   Print bdos error message.  
dce5			;  
dce5 e5			PRTERR: PUSH    HL              ;save second message pointer.  
dce6 cd c9 dd		        CALL    OUTCRLF         ;send (cr)(lf).  
dce9 3a 42 df		        LD      A,(ACTIVE)      ;get active drive.  
dcec c6 41		        ADD     A,'A'           ;make ascii.  
dcee 32 c6 dc		        LD      (BDOSDRV),A     ;and put in message.  
dcf1 01 ba dc		        LD      BC,BDOSERR      ;and print it.  
dcf4 cd d3 dd		        CALL    PRTMESG  
dcf7 c1			        POP     BC              ;print second message line now.  
dcf8 cd d3 dd		        CALL    PRTMESG  
dcfb			;  
dcfb			;   Get an input character. We will check our 1 character  
dcfb			; buffer first. This may be set by the console status routine.  
dcfb			;  
dcfb 21 0e df		GETCHAR:LD      HL,CHARBUF      ;check character buffer.  
dcfe 7e			        LD      A,(HL)          ;anything present already?  
dcff 36 00		        LD      (HL),0          ;...either case clear it.  
dd01 b7			        OR      A  
dd02 c0			        RET     NZ              ;yes, use it.  
dd03 c3 09 ea		        JP      CONIN           ;nope, go get a character responce.  
dd06			;  
dd06			;   Input and echo a character.  
dd06			;  
dd06 cd fb dc		GETECHO:CALL    GETCHAR         ;input a character.  
dd09 cd 14 dd		        CALL    CHKCHAR         ;carriage control?  
dd0c d8			        RET     C               ;no, a regular control char so don't echo.  
dd0d f5			        PUSH    AF              ;ok, save character now.  
dd0e 4f			        LD      C,A  
dd0f cd 90 dd		        CALL    OUTCON          ;and echo it.  
dd12 f1			        POP     AF              ;get character and return.  
dd13 c9			        RET       
dd14			;  
dd14			;   Check character in (A). Set the zero flag on a carriage  
dd14			; control character and the carry flag on any other control  
dd14			; character.  
dd14			;  
dd14 fe 0d		CHKCHAR:CP      CR              ;check for carriage return, line feed, backspace,  
dd16 c8			        RET     Z               ;or a tab.  
dd17 fe 0a		        CP      LF  
dd19 c8			        RET     Z  
dd1a fe 09		        CP      TAB  
dd1c c8			        RET     Z  
dd1d fe 08		        CP      BS  
dd1f c8			        RET     Z  
dd20 fe 20		        CP      ' '             ;other control char? Set carry flag.  
dd22 c9			        RET       
dd23			;  
dd23			;   Check the console during output. Halt on a control-s, then  
dd23			; reboot on a control-c. If anything else is ready, clear the  
dd23			; zero flag and return (the calling routine may want to do  
dd23			; something).  
dd23			;  
dd23 3a 0e df		CKCONSOL: LD    A,(CHARBUF)     ;check buffer.  
dd26 b7			        OR      A               ;if anything, just return without checking.  
dd27 c2 45 dd		        JP      NZ,CKCON2  
dd2a cd 06 ea		        CALL    CONST           ;nothing in buffer. Check console.  
dd2d e6 01		        AND     01H             ;look at bit 0.  
dd2f c8			        RET     Z               ;return if nothing.  
dd30 cd 09 ea		        CALL    CONIN           ;ok, get it.  
dd33 fe 13		        CP      CNTRLS          ;if not control-s, return with zero cleared.  
dd35 c2 42 dd		        JP      NZ,CKCON1  
dd38 cd 09 ea		        CALL    CONIN           ;halt processing until another char  
dd3b fe 03		        CP      CNTRLC          ;is typed. Control-c?  
dd3d ca 00 00		        JP      Z,0             ;yes, reboot now.  
dd40 af			        XOR     A               ;no, just pretend nothing was ever ready.  
dd41 c9			        RET       
dd42 32 0e df		CKCON1: LD      (CHARBUF),A     ;save character in buffer for later processing.  
dd45 3e 01		CKCON2: LD      A,1             ;set (A) to non zero to mean something is ready.  
dd47 c9			        RET       
dd48			;  
dd48			;   Output (C) to the screen. If the printer flip-flop flag  
dd48			; is set, we will send character to printer also. The console  
dd48			; will be checked in the process.  
dd48			;  
dd48 3a 0a df		OUTCHAR:LD      A,(OUTFLAG)     ;check output flag.  
dd4b b7			        OR      A               ;anything and we won't generate output.  
dd4c c2 62 dd		        JP      NZ,OUTCHR1  
dd4f c5			        PUSH    BC  
dd50 cd 23 dd		        CALL    CKCONSOL        ;check console (we don't care whats there).  
dd53 c1			        POP     BC  
dd54 c5			        PUSH    BC  
dd55 cd 0c ea		        CALL    CONOUT          ;output (C) to the screen.  
dd58 c1			        POP     BC  
dd59 c5			        PUSH    BC  
dd5a 3a 0d df		        LD      A,(PRTFLAG)     ;check printer flip-flop flag.  
dd5d b7			        OR      A  
dd5e c4 0f ea		        CALL    NZ,LIST         ;print it also if non-zero.  
dd61 c1			        POP     BC  
dd62 79			OUTCHR1:LD      A,C             ;update cursors position.  
dd63 21 0c df		        LD      HL,CURPOS  
dd66 fe 7f		        CP      DEL             ;rubouts don't do anything here.  
dd68 c8			        RET     Z  
dd69 34			        INC     (HL)            ;bump line pointer.  
dd6a fe 20		        CP      ' '             ;and return if a normal character.  
dd6c d0			        RET     NC  
dd6d 35			        DEC     (HL)            ;restore and check for the start of the line.  
dd6e 7e			        LD      A,(HL)  
dd6f b7			        OR      A  
dd70 c8			        RET     Z               ;ingnore control characters at the start of the line.  
dd71 79			        LD      A,C  
dd72 fe 08		        CP      BS              ;is it a backspace?  
dd74 c2 79 dd		        JP      NZ,OUTCHR2  
dd77 35			        DEC     (HL)            ;yes, backup pointer.  
dd78 c9			        RET       
dd79 fe 0a		OUTCHR2:CP      LF              ;is it a line feed?  
dd7b c0			        RET     NZ              ;ignore anything else.  
dd7c 36 00		        LD      (HL),0          ;reset pointer to start of line.  
dd7e c9			        RET       
dd7f			;  
dd7f			;   Output (A) to the screen. If it is a control character  
dd7f			; (other than carriage control), use ^x format.  
dd7f			;  
dd7f 79			SHOWIT: LD      A,C  
dd80 cd 14 dd		        CALL    CHKCHAR         ;check character.  
dd83 d2 90 dd		        JP      NC,OUTCON       ;not a control, use normal output.  
dd86 f5			        PUSH    AF  
dd87 0e 5e		        LD      C,'^'           ;for a control character, preceed it with '^'.  
dd89 cd 48 dd		        CALL    OUTCHAR  
dd8c f1			        POP     AF  
dd8d f6 40		        OR      '@'             ;and then use the letter equivelant.  
dd8f 4f			        LD      C,A  
dd90			;  
dd90			;   Function to output (C) to the console device and expand tabs  
dd90			; if necessary.  
dd90			;  
dd90 79			OUTCON: LD      A,C  
dd91 fe 09		        CP      TAB             ;is it a tab?  
dd93 c2 48 dd		        JP      NZ,OUTCHAR      ;use regular output.  
dd96 0e 20		OUTCON1:LD      C,' '           ;yes it is, use spaces instead.  
dd98 cd 48 dd		        CALL    OUTCHAR  
dd9b 3a 0c df		        LD      A,(CURPOS)      ;go until the cursor is at a multiple of 8  
dd9e			  
dd9e e6 07		        AND     07H             ;position.  
dda0 c2 96 dd		        JP      NZ,OUTCON1  
dda3 c9			        RET       
dda4			;  
dda4			;   Echo a backspace character. Erase the prevoius character  
dda4			; on the screen.  
dda4			;  
dda4 cd ac dd		BACKUP: CALL    BACKUP1         ;backup the screen 1 place.  
dda7 0e 20		        LD      C,' '           ;then blank that character.  
dda9 cd 0c ea		        CALL    CONOUT  
ddac 0e 08		BACKUP1:LD      C,BS            ;then back space once more.  
ddae c3 0c ea		        JP      CONOUT  
ddb1			;  
ddb1			;   Signal a deleted line. Print a '#' at the end and start  
ddb1			; over.  
ddb1			;  
ddb1 0e 23		NEWLINE:LD      C,'#'  
ddb3 cd 48 dd		        CALL    OUTCHAR         ;print this.  
ddb6 cd c9 dd		        CALL    OUTCRLF         ;start new line.  
ddb9 3a 0c df		NEWLN1: LD      A,(CURPOS)      ;move the cursor to the starting position.  
ddbc 21 0b df		        LD      HL,STARTING  
ddbf be			        CP      (HL)  
ddc0 d0			        RET     NC              ;there yet?  
ddc1 0e 20		        LD      C,' '  
ddc3 cd 48 dd		        CALL    OUTCHAR         ;nope, keep going.  
ddc6 c3 b9 dd		        JP      NEWLN1  
ddc9			;  
ddc9			;   Output a (cr) (lf) to the console device (screen).  
ddc9			;  
ddc9 0e 0d		OUTCRLF:LD      C,CR  
ddcb cd 48 dd		        CALL    OUTCHAR  
ddce 0e 0a		        LD      C,LF  
ddd0 c3 48 dd		        JP      OUTCHAR  
ddd3			;  
ddd3			;   Print message pointed to by (BC). It will end with a '$'.  
ddd3			;  
ddd3 0a			PRTMESG:LD      A,(BC)          ;check for terminating character.  
ddd4 fe 24		        CP      '$'  
ddd6 c8			        RET     Z  
ddd7 03			        INC     BC  
ddd8 c5			        PUSH    BC              ;otherwise, bump pointer and print it.  
ddd9 4f			        LD      C,A  
ddda cd 90 dd		        CALL    OUTCON  
dddd c1			        POP     BC  
ddde c3 d3 dd		        JP      PRTMESG  
dde1			;  
dde1			;   Function to execute a buffered read.  
dde1			;  
dde1 3a 0c df		RDBUFF: LD      A,(CURPOS)      ;use present location as starting one.  
dde4 32 0b df		        LD      (STARTING),A  
dde7 2a 43 df		        LD      HL,(PARAMS)     ;get the maximum buffer space.  
ddea 4e			        LD      C,(HL)  
ddeb 23			        INC     HL              ;point to first available space.  
ddec e5			        PUSH    HL              ;and save.  
dded 06 00		        LD      B,0             ;keep a character count.  
ddef c5			RDBUF1: PUSH    BC  
ddf0 e5			        PUSH    HL  
ddf1 cd fb dc		RDBUF2: CALL    GETCHAR         ;get the next input character.  
ddf4 e6 7f		        AND     7FH             ;strip bit 7.  
ddf6 e1			        POP     HL              ;reset registers.  
ddf7 c1			        POP     BC  
ddf8 fe 0d		        CP      CR              ;en of the line?  
ddfa ca c1 de		        JP      Z,RDBUF17  
ddfd fe 0a		        CP      LF  
ddff ca c1 de		        JP      Z,RDBUF17  
de02 fe 08		        CP      BS              ;how about a backspace?  
de04 c2 16 de		        JP      NZ,RDBUF3  
de07 78			        LD      A,B             ;yes, but ignore at the beginning of the line.  
de08 b7			        OR      A  
de09 ca ef dd		        JP      Z,RDBUF1  
de0c 05			        DEC     B               ;ok, update counter.  
de0d 3a 0c df		        LD      A,(CURPOS)      ;if we backspace to the start of the line,  
de10 32 0a df		        LD      (OUTFLAG),A     ;treat as a cancel (control-x).  
de13 c3 70 de		        JP      RDBUF10  
de16 fe 7f		RDBUF3: CP      DEL             ;user typed a rubout?  
de18 c2 26 de		        JP      NZ,RDBUF4  
de1b 78			        LD      A,B             ;ignore at the start of the line.  
de1c b7			        OR      A  
de1d ca ef dd		        JP      Z,RDBUF1  
de20 7e			        LD      A,(HL)          ;ok, echo the prevoius character.  
de21 05			        DEC     B               ;and reset pointers (counters).  
de22 2b			        DEC     HL  
de23 c3 a9 de		        JP      RDBUF15  
de26 fe 05		RDBUF4: CP      CNTRLE          ;physical end of line?  
de28 c2 37 de		        JP      NZ,RDBUF5  
de2b c5			        PUSH    BC              ;yes, do it.  
de2c e5			        PUSH    HL  
de2d cd c9 dd		        CALL    OUTCRLF  
de30 af			        XOR     A               ;and update starting position.  
de31 32 0b df		        LD      (STARTING),A  
de34 c3 f1 dd		        JP      RDBUF2  
de37 fe 10		RDBUF5: CP      CNTRLP          ;control-p?  
de39 c2 48 de		        JP      NZ,RDBUF6  
de3c e5			        PUSH    HL              ;yes, flip the print flag filp-flop byte.  
de3d 21 0d df		        LD      HL,PRTFLAG  
de40 3e 01		        LD      A,1             ;PRTFLAG=1-PRTFLAG  
de42 96			        SUB     (HL)  
de43 77			        LD      (HL),A  
de44 e1			        POP     HL  
de45 c3 ef dd		        JP      RDBUF1  
de48 fe 18		RDBUF6: CP      CNTRLX          ;control-x (cancel)?  
de4a c2 5f de		        JP      NZ,RDBUF8  
de4d e1			        POP     HL  
de4e 3a 0b df		RDBUF7: LD      A,(STARTING)    ;yes, backup the cursor to here.  
de51 21 0c df		        LD      HL,CURPOS  
de54 be			        CP      (HL)  
de55 d2 e1 dd		        JP      NC,RDBUFF       ;done yet?  
de58 35			        DEC     (HL)            ;no, decrement pointer and output back up one space.  
de59 cd a4 dd		        CALL    BACKUP  
de5c c3 4e de		        JP      RDBUF7  
de5f fe 15		RDBUF8: CP      CNTRLU          ;cntrol-u (cancel line)?  
de61 c2 6b de		        JP      NZ,RDBUF9  
de64 cd b1 dd		        CALL    NEWLINE         ;start a new line.  
de67 e1			        POP     HL  
de68 c3 e1 dd		        JP      RDBUFF  
de6b fe 12		RDBUF9: CP      CNTRLR          ;control-r?  
de6d c2 a6 de		        JP      NZ,RDBUF14  
de70 c5			RDBUF10:PUSH    BC              ;yes, start a new line and retype the old one.  
de71 cd b1 dd		        CALL    NEWLINE  
de74 c1			        POP     BC  
de75 e1			        POP     HL  
de76 e5			        PUSH    HL  
de77 c5			        PUSH    BC  
de78 78			RDBUF11:LD      A,B             ;done whole line yet?  
de79 b7			        OR      A  
de7a ca 8a de		        JP      Z,RDBUF12  
de7d 23			        INC     HL              ;nope, get next character.  
de7e 4e			        LD      C,(HL)  
de7f 05			        DEC     B               ;count it.  
de80 c5			        PUSH    BC  
de81 e5			        PUSH    HL  
de82 cd 7f dd		        CALL    SHOWIT          ;and display it.  
de85 e1			        POP     HL  
de86 c1			        POP     BC  
de87 c3 78 de		        JP      RDBUF11  
de8a e5			RDBUF12:PUSH    HL              ;done with line. If we were displaying  
de8b 3a 0a df		        LD      A,(OUTFLAG)     ;then update cursor position.  
de8e b7			        OR      A  
de8f ca f1 dd		        JP      Z,RDBUF2  
de92 21 0c df		        LD      HL,CURPOS       ;because this line is shorter, we must  
de95 96			        SUB     (HL)            ;back up the cursor (not the screen however)  
de96 32 0a df		        LD      (OUTFLAG),A     ;some number of positions.  
de99 cd a4 dd		RDBUF13:CALL    BACKUP          ;note that as long as (OUTFLAG) is non  
de9c 21 0a df		        LD      HL,OUTFLAG      ;zero, the screen will not be changed.  
de9f 35			        DEC     (HL)  
dea0 c2 99 de		        JP      NZ,RDBUF13  
dea3 c3 f1 dd		        JP      RDBUF2          ;now just get the next character.  
dea6			;  
dea6			;   Just a normal character, put this in our buffer and echo.  
dea6			;  
dea6 23			RDBUF14:INC     HL  
dea7 77			        LD      (HL),A          ;store character.  
dea8 04			        INC     B               ;and count it.  
dea9 c5			RDBUF15:PUSH    BC  
deaa e5			        PUSH    HL  
deab 4f			        LD      C,A             ;echo it now.  
deac cd 7f dd		        CALL    SHOWIT  
deaf e1			        POP     HL  
deb0 c1			        POP     BC  
deb1 7e			        LD      A,(HL)          ;was it an abort request?  
deb2 fe 03		        CP      CNTRLC          ;control-c abort?  
deb4 78			        LD      A,B  
deb5 c2 bd de		        JP      NZ,RDBUF16  
deb8 fe 01		        CP      1               ;only if at start of line.  
deba ca 00 00		        JP      Z,0  
debd b9			RDBUF16:CP      C               ;nope, have we filled the buffer?  
debe da ef dd		        JP      C,RDBUF1  
dec1 e1			RDBUF17:POP     HL              ;yes end the line and return.  
dec2 70			        LD      (HL),B  
dec3 0e 0d		        LD      C,CR  
dec5 c3 48 dd		        JP      OUTCHAR         ;output (cr) and return.  
dec8			;  
dec8			;   Function to get a character from the console device.  
dec8			;  
dec8 cd 06 dd		GETCON: CALL    GETECHO         ;get and echo.  
decb c3 01 df		        JP      SETSTAT         ;save status and return.  
dece			;  
dece			;   Function to get a character from the tape reader device.  
dece			;  
dece cd 15 ea		GETRDR: CALL    READER          ;get a character from reader, set status and return.  
ded1 c3 01 df		        JP      SETSTAT  
ded4			;  
ded4			;  Function to perform direct console i/o. If (C) contains (FF)  
ded4			; then this is an input request. If (C) contains (FE) then  
ded4			; this is a status request. Otherwise we are to output (C).  
ded4			;  
ded4 79			DIRCIO: LD      A,C             ;test for (FF).  
ded5 3c			        INC     A  
ded6 ca e0 de		        JP      Z,DIRC1  
ded9 3c			        INC     A               ;test for (FE).  
deda ca 06 ea		        JP      Z,CONST  
dedd c3 0c ea		        JP      CONOUT          ;just output (C).  
dee0 cd 06 ea		DIRC1:  CALL    CONST           ;this is an input request.  
dee3 b7			        OR      A  
dee4 ca 91 e9		        JP      Z,GOBACK1       ;not ready? Just return (directly).  
dee7 cd 09 ea		        CALL    CONIN           ;yes, get character.  
deea c3 01 df		        JP      SETSTAT         ;set status and return.  
deed			;  
deed			;   Function to return the i/o byte.  
deed			;  
deed 3a 03 00		GETIOB: LD      A,(IOBYTE)  
def0 c3 01 df		        JP      SETSTAT  
def3			;  
def3			;   Function to set the i/o byte.  
def3			;  
def3 21 03 00		SETIOB: LD      HL,IOBYTE  
def6 71			        LD      (HL),C  
def7 c9			        RET       
def8			;  
def8			;   Function to print the character string pointed to by (DE)  
def8			; on the console device. The string ends with a '$'.  
def8			;  
def8 eb			PRTSTR: EX      DE,HL  
def9 4d			        LD      C,L  
defa 44			        LD      B,H             ;now (BC) points to it.  
defb c3 d3 dd		        JP      PRTMESG  
defe			;  
defe			;   Function to interigate the console device.  
defe			;  
defe cd 23 dd		GETCSTS:CALL    CKCONSOL  
df01			;  
df01			;   Get here to set the status and return to the cleanup  
df01			; section. Then back to the user.  
df01			;  
df01 32 45 df		SETSTAT:LD      (STATUS),A  
df04 c9			RTN:    RET       
df05			;  
df05			;   Set the status to 1 (read or write error code).  
df05			;  
df05 3e 01		IOERR1: LD      A,1  
df07 c3 01 df		        JP      SETSTAT  
df0a			;  
df0a 00			OUTFLAG:DEFB    0               ;output flag (non zero means no output).  
df0b 02			STARTING: DEFB  2               ;starting position for cursor.  
df0c 00			CURPOS: DEFB    0               ;cursor position (0=start of line).  
df0d 00			PRTFLAG:DEFB    0               ;printer flag (control-p toggle). List if non zero.  
df0e 00			CHARBUF:DEFB    0               ;single input character buffer.  
df0f			;  
df0f			;   Stack area for BDOS calls.  
df0f			;  
df0f 00 00		USRSTACK: DEFW  0               ;save users stack pointer here.  
df11			;  
df11 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00	        DEFB    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0  
df29 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00	        DEFB    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0  
df41			STKAREA: EQU     $               ;end of stack area.  
df41			;  
df41 00			USERNO: DEFB    0               ;current user number.  
df42 00			ACTIVE: DEFB    0               ;currently active drive.  
df43 00 00		PARAMS: DEFW    0               ;save (DE) parameters here on entry.  
df45 00 00		STATUS: DEFW    0               ;status returned from bdos function.  
df47			;  
df47			;   Select error occured, jump to error routine.  
df47			;  
df47 21 0b dc		SLCTERR:LD      HL,BADSLCT  
df4a			;  
df4a			;   Jump to (HL) indirectly.  
df4a			;  
df4a 5e			JUMPHL: LD      E,(HL)  
df4b 23			        INC     HL  
df4c 56			        LD      D,(HL)          ;now (DE) contain the desired address.  
df4d eb			        EX      DE,HL  
df4e e9			        JP      (HL)  
df4f			;  
df4f			;   Block move. (DE) to (HL), (C) bytes total.  
df4f			;  
df4f 0c			DE2HL:  INC     C               ;is count down to zero?  
df50 0d			DE2HL1: DEC     C  
df51 c8			        RET     Z               ;yes, we are done.  
df52 1a			        LD      A,(DE)          ;no, move one more byte.  
df53 77			        LD      (HL),A  
df54 13			        INC     DE  
df55 23			        INC     HL  
df56 c3 50 df		        JP      DE2HL1          ;and repeat.  
df59			;  
df59			;   Select the desired drive.  
df59			;  
df59 3a 42 df		SELECT: LD      A,(ACTIVE)      ;get active disk.  
df5c 4f			        LD      C,A  
df5d cd 1b ea		        CALL    SELDSK          ;select it.  
df60 7c			        LD      A,H             ;valid drive?  
df61 b5			        OR      L               ;valid drive?  
df62 c8			        RET     Z               ;return if not.  
df63			;  
df63			;   Here, the BIOS returned the address of the parameter block  
df63			; in (HL). We will extract the necessary pointers and save them.  
df63			;  
df63 5e			        LD      E,(HL)          ;yes, get address of translation table into (DE).  
df64 23			        INC     HL  
df65 56			        LD      D,(HL)  
df66 23			        INC     HL  
df67 22 b3 e9		        LD      (SCRATCH1),HL   ;save pointers to scratch areas.  
df6a 23			        INC     HL  
df6b 23			        INC     HL  
df6c 22 b5 e9		        LD      (SCRATCH2),HL   ;ditto.  
df6f 23			        INC     HL  
df70 23			        INC     HL  
df71 22 b7 e9		        LD      (SCRATCH3),HL   ;ditto.  
df74 23			        INC     HL  
df75 23			        INC     HL  
df76 eb			        EX      DE,HL           ;now save the translation table address.  
df77 22 d0 e9		        LD      (XLATE),HL  
df7a 21 b9 e9		        LD      HL,DIRBUF       ;put the next 8 bytes here.  
df7d 0e 08		        LD      C,8             ;they consist of the directory buffer  
df7f cd 4f df		        CALL    DE2HL           ;pointer, parameter block pointer,  
df82 2a bb e9		        LD      HL,(DISKPB)     ;check and allocation vectors.  
df85 eb			        EX      DE,HL  
df86 21 c1 e9		        LD      HL,SECTORS      ;move parameter block into our ram.  
df89 0e 0f		        LD      C,15            ;it is 15 bytes long.  
df8b cd 4f df		        CALL    DE2HL  
df8e 2a c6 e9		        LD      HL,(DSKSIZE)    ;check disk size.  
df91 7c			        LD      A,H             ;more than 256 blocks on this?  
df92 21 dd e9		        LD      HL,BIGDISK  
df95 36 ff		        LD      (HL),0FFH       ;set to samll.  
df97 b7			        OR      A  
df98 ca 9d df		        JP      Z,SELECT1  
df9b 36 00		        LD      (HL),0          ;wrong, set to large.  
df9d 3e ff		SELECT1:LD      A,0FFH          ;clear the zero flag.  
df9f b7			        OR      A  
dfa0 c9			        RET       
dfa1			;  
dfa1			;   Routine to home the disk track head and clear pointers.  
dfa1			;  
dfa1 cd 18 ea		HOMEDRV:CALL    HOME            ;home the head.  
dfa4 af			        XOR     A  
dfa5 2a b5 e9		        LD      HL,(SCRATCH2)   ;set our track pointer also.  
dfa8 77			        LD      (HL),A  
dfa9 23			        INC     HL  
dfaa 77			        LD      (HL),A  
dfab 2a b7 e9		        LD      HL,(SCRATCH3)   ;and our sector pointer.  
dfae 77			        LD      (HL),A  
dfaf 23			        INC     HL  
dfb0 77			        LD      (HL),A  
dfb1 c9			        RET       
dfb2			;  
dfb2			;   Do the actual disk read and check the error return status.  
dfb2			;  
dfb2 cd 27 ea		DOREAD: CALL    READ  
dfb5 c3 bb df		        JP      IORET  
dfb8			;  
dfb8			;   Do the actual disk write and handle any bios error.  
dfb8			;  
dfb8 cd 2a ea		DOWRITE:CALL    WRITE  
dfbb b7			IORET:  OR      A  
dfbc c8			        RET     Z               ;return unless an error occured.  
dfbd 21 09 dc		        LD      HL,BADSCTR      ;bad read/write on this sector.  
dfc0 c3 4a df		        JP      JUMPHL  
dfc3			;  
dfc3			;   Routine to select the track and sector that the desired  
dfc3			; block number falls in.  
dfc3			;  
dfc3 2a ea e9		TRKSEC: LD      HL,(FILEPOS)    ;get position of last accessed file  
dfc6 0e 02		        LD      C,2             ;in directory and compute sector #.  
dfc8 cd ea e0		        CALL    SHIFTR          ;sector #=file-position/4.  
dfcb 22 e5 e9		        LD      (BLKNMBR),HL    ;save this as the block number of interest.  
dfce 22 ec e9		        LD      (CKSUMTBL),HL   ;what's it doing here too?  
dfd1			;  
dfd1			;   if the sector number has already been set (BLKNMBR), enter  
dfd1			; at this point.  
dfd1			;  
dfd1 21 e5 e9		TRKSEC1:LD      HL,BLKNMBR  
dfd4 4e			        LD      C,(HL)          ;move sector number into (BC).  
dfd5 23			        INC     HL  
dfd6 46			        LD      B,(HL)  
dfd7 2a b7 e9		        LD      HL,(SCRATCH3)   ;get current sector number and  
dfda 5e			        LD      E,(HL)          ;move this into (DE).  
dfdb 23			        INC     HL  
dfdc 56			        LD      D,(HL)  
dfdd 2a b5 e9		        LD      HL,(SCRATCH2)   ;get current track number.  
dfe0 7e			        LD      A,(HL)          ;and this into (HL).  
dfe1 23			        INC     HL  
dfe2 66			        LD      H,(HL)  
dfe3 6f			        LD      L,A  
dfe4 79			TRKSEC2:LD      A,C             ;is desired sector before current one?  
dfe5 93			        SUB     E  
dfe6 78			        LD      A,B  
dfe7 9a			        SBC     A,D  
dfe8 d2 fa df		        JP      NC,TRKSEC3  
dfeb e5			        PUSH    HL              ;yes, decrement sectors by one track.  
dfec 2a c1 e9		        LD      HL,(SECTORS)    ;get sectors per track.  
dfef 7b			        LD      A,E  
dff0 95			        SUB     L  
dff1 5f			        LD      E,A  
dff2 7a			        LD      A,D  
dff3 9c			        SBC     A,H  
dff4 57			        LD      D,A             ;now we have backed up one full track.  
dff5 e1			        POP     HL  
dff6 2b			        DEC     HL              ;adjust track counter.  
dff7 c3 e4 df		        JP      TRKSEC2  
dffa e5			TRKSEC3:PUSH    HL              ;desired sector is after current one.  
dffb 2a c1 e9		        LD      HL,(SECTORS)    ;get sectors per track.  
dffe 19			        ADD     HL,DE           ;bump sector pointer to next track.  
dfff da 0f e0		        JP      C,TRKSEC4  
e002 79			        LD      A,C             ;is desired sector now before current one?  
e003 95			        SUB     L  
e004 78			        LD      A,B  
e005 9c			        SBC     A,H  
e006 da 0f e0		        JP      C,TRKSEC4  
e009 eb			        EX      DE,HL           ;not yes, increment track counter  
e00a e1			        POP     HL              ;and continue until it is.  
e00b 23			        INC     HL  
e00c c3 fa df		        JP      TRKSEC3  
e00f			;  
e00f			;   here we have determined the track number that contains the  
e00f			; desired sector.  
e00f			;  
e00f e1			TRKSEC4:POP     HL              ;get track number (HL).  
e010 c5			        PUSH    BC  
e011 d5			        PUSH    DE  
e012 e5			        PUSH    HL  
e013 eb			        EX      DE,HL  
e014 2a ce e9		        LD      HL,(OFFSET)     ;adjust for first track offset.  
e017 19			        ADD     HL,DE  
e018 44			        LD      B,H  
e019 4d			        LD      C,L  
e01a cd 1e ea		        CALL    SETTRK          ;select this track.  
e01d d1			        POP     DE              ;reset current track pointer.  
e01e 2a b5 e9		        LD      HL,(SCRATCH2)  
e021 73			        LD      (HL),E  
e022 23			        INC     HL  
e023 72			        LD      (HL),D  
e024 d1			        POP     DE  
e025 2a b7 e9		        LD      HL,(SCRATCH3)   ;reset the first sector on this track.  
e028 73			        LD      (HL),E  
e029 23			        INC     HL  
e02a 72			        LD      (HL),D  
e02b c1			        POP     BC  
e02c 79			        LD      A,C             ;now subtract the desired one.  
e02d 93			        SUB     E               ;to make it relative (1-# sectors/track).  
e02e 4f			        LD      C,A  
e02f 78			        LD      A,B  
e030 9a			        SBC     A,D  
e031 47			        LD      B,A  
e032 2a d0 e9		        LD      HL,(XLATE)      ;translate this sector according to this table.  
e035 eb			        EX      DE,HL  
e036 cd 30 ea		        CALL    SECTRN          ;let the bios translate it.  
e039 4d			        LD      C,L  
e03a 44			        LD      B,H  
e03b c3 21 ea		        JP      SETSEC          ;and select it.  
e03e			;  
e03e			;   Compute block number from record number (SAVNREC) and  
e03e			; extent number (SAVEXT).  
e03e			;  
e03e 21 c3 e9		GETBLOCK: LD    HL,BLKSHFT      ;get logical to physical conversion.  
e041 4e			        LD      C,(HL)          ;note that this is base 2 log of ratio.  
e042 3a e3 e9		        LD      A,(SAVNREC)     ;get record number.  
e045 b7			GETBLK1:OR      A               ;compute (A)=(A)/2^BLKSHFT.  
e046 1f			        RRA       
e047 0d			        DEC     C  
e048 c2 45 e0		        JP      NZ,GETBLK1  
e04b 47			        LD      B,A             ;save result in (B).  
e04c 3e 08		        LD      A,8  
e04e 96			        SUB     (HL)  
e04f 4f			        LD      C,A             ;compute (C)=8-BLKSHFT.  
e050 3a e2 e9		        LD      A,(SAVEXT)  
e053 0d			GETBLK2:DEC     C               ;compute (A)=SAVEXT*2^(8-BLKSHFT).  
e054 ca 5c e0		        JP      Z,GETBLK3  
e057 b7			        OR      A  
e058 17			        RLA       
e059 c3 53 e0		        JP      GETBLK2  
e05c 80			GETBLK3:ADD     A,B  
e05d c9			        RET       
e05e			;  
e05e			;   Routine to extract the (BC) block byte from the fcb pointed  
e05e			; to by (PARAMS). If this is a big-disk, then these are 16 bit  
e05e			; block numbers, else they are 8 bit numbers.  
e05e			; Number is returned in (HL).  
e05e			;  
e05e 2a 43 df		EXTBLK: LD      HL,(PARAMS)     ;get fcb address.  
e061 11 10 00		        LD      DE,16           ;block numbers start 16 bytes into fcb.  
e064 19			        ADD     HL,DE  
e065 09			        ADD     HL,BC  
e066 3a dd e9		        LD      A,(BIGDISK)     ;are we using a big-disk?  
e069 b7			        OR      A  
e06a ca 71 e0		        JP      Z,EXTBLK1  
e06d 6e			        LD      L,(HL)          ;no, extract an 8 bit number from the fcb.  
e06e 26 00		        LD      H,0  
e070 c9			        RET       
e071 09			EXTBLK1:ADD     HL,BC           ;yes, extract a 16 bit number.  
e072 5e			        LD      E,(HL)  
e073 23			        INC     HL  
e074 56			        LD      D,(HL)  
e075 eb			        EX      DE,HL           ;return in (HL).  
e076 c9			        RET       
e077			;  
e077			;   Compute block number.  
e077			;  
e077 cd 3e e0		COMBLK: CALL    GETBLOCK  
e07a 4f			        LD      C,A  
e07b 06 00		        LD      B,0  
e07d cd 5e e0		        CALL    EXTBLK  
e080 22 e5 e9		        LD      (BLKNMBR),HL  
e083 c9			        RET       
e084			;  
e084			;   Check for a zero block number (unused).  
e084			;  
e084 2a e5 e9		CHKBLK: LD      HL,(BLKNMBR)  
e087 7d			        LD      A,L             ;is it zero?  
e088 b4			        OR      H  
e089 c9			        RET       
e08a			;  
e08a			;   Adjust physical block (BLKNMBR) and convert to logical  
e08a			; sector (LOGSECT). This is the starting sector of this block.  
e08a			; The actual sector of interest is then added to this and the  
e08a			; resulting sector number is stored back in (BLKNMBR). This  
e08a			; will still have to be adjusted for the track number.  
e08a			;  
e08a 3a c3 e9		LOGICAL:LD      A,(BLKSHFT)     ;get log2(physical/logical sectors).  
e08d 2a e5 e9		        LD      HL,(BLKNMBR)    ;get physical sector desired.  
e090 29			LOGICL1:ADD     HL,HL           ;compute logical sector number.  
e091 3d			        DEC     A               ;note logical sectors are 128 bytes long.  
e092 c2 90 e0		        JP      NZ,LOGICL1  
e095 22 e7 e9		        LD      (LOGSECT),HL    ;save logical sector.  
e098 3a c4 e9		        LD      A,(BLKMASK)     ;get block mask.  
e09b 4f			        LD      C,A  
e09c 3a e3 e9		        LD      A,(SAVNREC)     ;get next sector to access.  
e09f a1			        AND     C               ;extract the relative position within physical block.  
e0a0 b5			        OR      L               ;and add it too logical sector.  
e0a1 6f			        LD      L,A  
e0a2 22 e5 e9		        LD      (BLKNMBR),HL    ;and store.  
e0a5 c9			        RET       
e0a6			;  
e0a6			;   Set (HL) to point to extent byte in fcb.  
e0a6			;  
e0a6 2a 43 df		SETEXT: LD      HL,(PARAMS)  
e0a9 11 0c 00		        LD      DE,12           ;it is the twelth byte.  
e0ac 19			        ADD     HL,DE  
e0ad c9			        RET       
e0ae			;  
e0ae			;   Set (HL) to point to record count byte in fcb and (DE) to  
e0ae			; next record number byte.  
e0ae			;  
e0ae 2a 43 df		SETHLDE:LD      HL,(PARAMS)  
e0b1 11 0f 00		        LD      DE,15           ;record count byte (#15).  
e0b4 19			        ADD     HL,DE  
e0b5 eb			        EX      DE,HL  
e0b6 21 11 00		        LD      HL,17           ;next record number (#32).  
e0b9 19			        ADD     HL,DE  
e0ba c9			        RET       
e0bb			;  
e0bb			;   Save current file data from fcb.  
e0bb			;  
e0bb cd ae e0		STRDATA:CALL    SETHLDE  
e0be 7e			        LD      A,(HL)          ;get and store record count byte.  
e0bf 32 e3 e9		        LD      (SAVNREC),A  
e0c2 eb			        EX      DE,HL  
e0c3 7e			        LD      A,(HL)          ;get and store next record number byte.  
e0c4 32 e1 e9		        LD      (SAVNXT),A  
e0c7 cd a6 e0		        CALL    SETEXT          ;point to extent byte.  
e0ca 3a c5 e9		        LD      A,(EXTMASK)     ;get extent mask.  
e0cd a6			        AND     (HL)  
e0ce 32 e2 e9		        LD      (SAVEXT),A      ;and save extent here.  
e0d1 c9			        RET       
e0d2			;  
e0d2			;   Set the next record to access. If (MODE) is set to 2, then  
e0d2			; the last record byte (SAVNREC) has the correct number to access.  
e0d2			; For sequential access, (MODE) will be equal to 1.  
e0d2			;  
e0d2 cd ae e0		SETNREC:CALL    SETHLDE  
e0d5 3a d5 e9		        LD      A,(MODE)        ;get sequential flag (=1).  
e0d8 fe 02		        CP      2               ;a 2 indicates that no adder is needed.  
e0da c2 de e0		        JP      NZ,STNREC1  
e0dd af			        XOR     A               ;clear adder (random access?).  
e0de 4f			STNREC1:LD      C,A  
e0df 3a e3 e9		        LD      A,(SAVNREC)     ;get last record number.  
e0e2 81			        ADD     A,C             ;increment record count.  
e0e3 77			        LD      (HL),A          ;and set fcb's next record byte.  
e0e4 eb			        EX      DE,HL  
e0e5 3a e1 e9		        LD      A,(SAVNXT)      ;get next record byte from storage.  
e0e8 77			        LD      (HL),A          ;and put this into fcb as number of records used.  
e0e9 c9			        RET       
e0ea			;  
e0ea			;   Shift (HL) right (C) bits.  
e0ea			;  
e0ea 0c			SHIFTR: INC     C  
e0eb 0d			SHIFTR1:DEC     C  
e0ec c8			        RET     Z  
e0ed 7c			        LD      A,H  
e0ee b7			        OR      A  
e0ef 1f			        RRA       
e0f0 67			        LD      H,A  
e0f1 7d			        LD      A,L  
e0f2 1f			        RRA       
e0f3 6f			        LD      L,A  
e0f4 c3 eb e0		        JP      SHIFTR1  
e0f7			;  
e0f7			;   Compute the check-sum for the directory buffer. Return  
e0f7			; integer sum in (A).  
e0f7			;  
e0f7 0e 80		CHECKSUM: LD    C,128           ;length of buffer.  
e0f9 2a b9 e9		        LD      HL,(DIRBUF)     ;get its location.  
e0fc af			        XOR     A               ;clear summation byte.  
e0fd 86			CHKSUM1:ADD     A,(HL)             ;and compute sum ignoring carries.  
e0fe 23			        INC     HL  
e0ff 0d			        DEC     C  
e100 c2 fd e0		        JP      NZ,CHKSUM1  
e103 c9			        RET       
e104			;  
e104			;   Shift (HL) left (C) bits.  
e104			;  
e104 0c			SHIFTL: INC     C  
e105 0d			SHIFTL1:DEC     C  
e106 c8			        RET     Z  
e107 29			        ADD     HL,HL           ;shift left 1 bit.  
e108 c3 05 e1		        JP      SHIFTL1  
e10b			;  
e10b			;   Routine to set a bit in a 16 bit value contained in (BC).  
e10b			; The bit set depends on the current drive selection.  
e10b			;  
e10b c5			SETBIT: PUSH    BC              ;save 16 bit word.  
e10c 3a 42 df		        LD      A,(ACTIVE)      ;get active drive.  
e10f 4f			        LD      C,A  
e110 21 01 00		        LD      HL,1  
e113 cd 04 e1		        CALL    SHIFTL          ;shift bit 0 into place.  
e116 c1			        POP     BC              ;now 'or' this with the original word.  
e117 79			        LD      A,C  
e118 b5			        OR      L  
e119 6f			        LD      L,A             ;low byte done, do high byte.  
e11a 78			        LD      A,B  
e11b b4			        OR      H  
e11c 67			        LD      H,A  
e11d c9			        RET       
e11e			;  
e11e			;   Extract the write protect status bit for the current drive.  
e11e			; The result is returned in (A), bit 0.  
e11e			;  
e11e 2a ad e9		GETWPRT:LD      HL,(WRTPRT)     ;get status bytes.  
e121 3a 42 df		        LD      A,(ACTIVE)      ;which drive is current?  
e124 4f			        LD      C,A  
e125 cd ea e0		        CALL    SHIFTR          ;shift status such that bit 0 is the  
e128 7d			        LD      A,L             ;one of interest for this drive.  
e129 e6 01		        AND     01H             ;and isolate it.  
e12b c9			        RET       
e12c			;  
e12c			;   Function to write protect the current disk.  
e12c			;  
e12c 21 ad e9		WRTPRTD:LD      HL,WRTPRT       ;point to status word.  
e12f 4e			        LD      C,(HL)          ;set (BC) equal to the status.  
e130 23			        INC     HL  
e131 46			        LD      B,(HL)  
e132 cd 0b e1		        CALL    SETBIT          ;and set this bit according to current drive.  
e135 22 ad e9		        LD      (WRTPRT),HL     ;then save.  
e138 2a c8 e9		        LD      HL,(DIRSIZE)    ;now save directory size limit.  
e13b 23			        INC     HL              ;remember the last one.  
e13c eb			        EX      DE,HL  
e13d 2a b3 e9		        LD      HL,(SCRATCH1)   ;and store it here.  
e140 73			        LD      (HL),E          ;put low byte.  
e141 23			        INC     HL  
e142 72			        LD      (HL),D          ;then high byte.  
e143 c9			        RET       
e144			;  
e144			;   Check for a read only file.  
e144			;  
e144 cd 5e e1		CHKROFL:CALL    FCB2HL          ;set (HL) to file entry in directory buffer.  
e147 11 09 00		CKROF1: LD      DE,9            ;look at bit 7 of the ninth byte.  
e14a 19			        ADD     HL,DE  
e14b 7e			        LD      A,(HL)  
e14c 17			        RLA       
e14d d0			        RET     NC              ;return if ok.  
e14e 21 0f dc		        LD      HL,ROFILE       ;else, print error message and terminate.  
e151 c3 4a df		        JP      JUMPHL  
e154			;  
e154			;   Check the write protect status of the active disk.  
e154			;  
e154 cd 1e e1		CHKWPRT:CALL    GETWPRT  
e157 c8			        RET     Z               ;return if ok.  
e158 21 0d dc		        LD      HL,RODISK       ;else print message and terminate.  
e15b c3 4a df		        JP      JUMPHL  
e15e			;  
e15e			;   Routine to set (HL) pointing to the proper entry in the  
e15e			; directory buffer.  
e15e			;  
e15e 2a b9 e9		FCB2HL: LD      HL,(DIRBUF)     ;get address of buffer.  
e161 3a e9 e9		        LD      A,(FCBPOS)      ;relative position of file.  
e164			;  
e164			;   Routine to add (A) to (HL).  
e164			;  
e164 85			ADDA2HL:ADD     A,L  
e165 6f			        LD      L,A  
e166 d0			        RET     NC  
e167 24			        INC     H               ;take care of any carry.  
e168 c9			        RET       
e169			;  
e169			;   Routine to get the 's2' byte from the fcb supplied in  
e169			; the initial parameter specification.  
e169			;  
e169 2a 43 df		GETS2:  LD      HL,(PARAMS)     ;get address of fcb.  
e16c 11 0e 00		        LD      DE,14           ;relative position of 's2'.  
e16f 19			        ADD     HL,DE  
e170 7e			        LD      A,(HL)          ;extract this byte.  
e171 c9			        RET       
e172			;  
e172			;   Clear the 's2' byte in the fcb.  
e172			;  
e172 cd 69 e1		CLEARS2:CALL    GETS2           ;this sets (HL) pointing to it.  
e175 36 00		        LD      (HL),0          ;now clear it.  
e177 c9			        RET       
e178			;  
e178			;   Set bit 7 in the 's2' byte of the fcb.  
e178			;  
e178 cd 69 e1		SETS2B7:CALL    GETS2           ;get the byte.  
e17b f6 80		        OR      80H             ;and set bit 7.  
e17d 77			        LD      (HL),A          ;then store.  
e17e c9			        RET       
e17f			;  
e17f			;   Compare (FILEPOS) with (SCRATCH1) and set flags based on  
e17f			; the difference. This checks to see if there are more file  
e17f			; names in the directory. We are at (FILEPOS) and there are  
e17f			; (SCRATCH1) of them to check.  
e17f			;  
e17f 2a ea e9		MOREFLS:LD      HL,(FILEPOS)    ;we are here.  
e182 eb			        EX      DE,HL  
e183 2a b3 e9		        LD      HL,(SCRATCH1)   ;and don't go past here.  
e186 7b			        LD      A,E             ;compute difference but don't keep.  
e187 96			        SUB     (HL)  
e188 23			        INC     HL  
e189 7a			        LD      A,D  
e18a 9e			        SBC     A,(HL)             ;set carry if no more names.  
e18b c9			        RET       
e18c			;  
e18c			;   Call this routine to prevent (SCRATCH1) from being greater  
e18c			; than (FILEPOS).  
e18c			;  
e18c cd 7f e1		CHKNMBR:CALL    MOREFLS         ;SCRATCH1 too big?  
e18f d8			        RET     C  
e190 13			        INC     DE              ;yes, reset it to (FILEPOS).  
e191 72			        LD      (HL),D  
e192 2b			        DEC     HL  
e193 73			        LD      (HL),E  
e194 c9			        RET       
e195			;  
e195			;   Compute (HL)=(DE)-(HL)  
e195			;  
e195 7b			SUBHL:  LD      A,E             ;compute difference.  
e196 95			        SUB     L  
e197 6f			        LD      L,A             ;store low byte.  
e198 7a			        LD      A,D  
e199 9c			        SBC     A,H  
e19a 67			        LD      H,A             ;and then high byte.  
e19b c9			        RET       
e19c			;  
e19c			;   Set the directory checksum byte.  
e19c			;  
e19c 0e ff		SETDIR: LD      C,0FFH  
e19e			;  
e19e			;   Routine to set or compare the directory checksum byte. If  
e19e			; (C)=0ffh, then this will set the checksum byte. Else the byte  
e19e			; will be checked. If the check fails (the disk has been changed),  
e19e			; then this disk will be write protected.  
e19e			;  
e19e 2a ec e9		CHECKDIR: LD    HL,(CKSUMTBL)  
e1a1 eb			        EX      DE,HL  
e1a2 2a cc e9		        LD      HL,(ALLOC1)  
e1a5 cd 95 e1		        CALL    SUBHL  
e1a8 d0			        RET     NC              ;ok if (CKSUMTBL) > (ALLOC1), so return.  
e1a9 c5			        PUSH    BC  
e1aa cd f7 e0		        CALL    CHECKSUM        ;else compute checksum.  
e1ad 2a bd e9		        LD      HL,(CHKVECT)    ;get address of checksum table.  
e1b0 eb			        EX      DE,HL  
e1b1 2a ec e9		        LD      HL,(CKSUMTBL)  
e1b4 19			        ADD     HL,DE           ;set (HL) to point to byte for this drive.  
e1b5 c1			        POP     BC  
e1b6 0c			        INC     C               ;set or check ?  
e1b7 ca c4 e1		        JP      Z,CHKDIR1  
e1ba be			        CP      (HL)            ;check them.  
e1bb c8			        RET     Z               ;return if they are the same.  
e1bc cd 7f e1		        CALL    MOREFLS         ;not the same, do we care?  
e1bf d0			        RET     NC  
e1c0 cd 2c e1		        CALL    WRTPRTD         ;yes, mark this as write protected.  
e1c3 c9			        RET       
e1c4 77			CHKDIR1:LD      (HL),A          ;just set the byte.  
e1c5 c9			        RET       
e1c6			;  
e1c6			;   Do a write to the directory of the current disk.  
e1c6			;  
e1c6 cd 9c e1		DIRWRITE: CALL  SETDIR          ;set checksum byte.  
e1c9 cd e0 e1		        CALL    DIRDMA          ;set directory dma address.  
e1cc 0e 01		        LD      C,1             ;tell the bios to actually write.  
e1ce cd b8 df		        CALL    DOWRITE         ;then do the write.  
e1d1 c3 da e1		        JP      DEFDMA  
e1d4			;  
e1d4			;   Read from the directory.  
e1d4			;  
e1d4 cd e0 e1		DIRREAD:CALL    DIRDMA          ;set the directory dma address.  
e1d7 cd b2 df		        CALL    DOREAD          ;and read it.  
e1da			;  
e1da			;   Routine to set the dma address to the users choice.  
e1da			;  
e1da 21 b1 e9		DEFDMA: LD      HL,USERDMA      ;reset the default dma address and return.  
e1dd c3 e3 e1		        JP      DIRDMA1  
e1e0			;  
e1e0			;   Routine to set the dma address for directory work.  
e1e0			;  
e1e0 21 b9 e9		DIRDMA: LD      HL,DIRBUF  
e1e3			;  
e1e3			;   Set the dma address. On entry, (HL) points to  
e1e3			; word containing the desired dma address.  
e1e3			;  
e1e3 4e			DIRDMA1:LD      C,(HL)  
e1e4 23			        INC     HL  
e1e5 46			        LD      B,(HL)          ;setup (BC) and go to the bios to set it.  
e1e6 c3 24 ea		        JP      SETDMA  
e1e9			;  
e1e9			;   Move the directory buffer into user's dma space.  
e1e9			;  
e1e9 2a b9 e9		MOVEDIR:LD      HL,(DIRBUF)     ;buffer is located here, and  
e1ec eb			        EX      DE,HL  
e1ed 2a b1 e9		        LD      HL,(USERDMA)    ; put it here.  
e1f0 0e 80		        LD      C,128           ;this is its length.  
e1f2 c3 4f df		        JP      DE2HL           ;move it now and return.  
e1f5			;  
e1f5			;   Check (FILEPOS) and set the zero flag if it equals 0ffffh.  
e1f5			;  
e1f5 21 ea e9		CKFILPOS: LD    HL,FILEPOS  
e1f8 7e			        LD      A,(HL)  
e1f9 23			        INC     HL  
e1fa be			        CP      (HL)            ;are both bytes the same?  
e1fb c0			        RET     NZ  
e1fc 3c			        INC     A               ;yes, but are they each 0ffh?  
e1fd c9			        RET       
e1fe			;  
e1fe			;   Set location (FILEPOS) to 0ffffh.  
e1fe			;  
e1fe 21 ff ff		STFILPOS: LD    HL,0FFFFH  
e201 22 ea e9		        LD      (FILEPOS),HL  
e204 c9			        RET       
e205			;  
e205			;   Move on to the next file position within the current  
e205			; directory buffer. If no more exist, set pointer to 0ffffh  
e205			; and the calling routine will check for this. Enter with (C)  
e205			; equal to 0ffh to cause the checksum byte to be set, else we  
e205			; will check this disk and set write protect if checksums are  
e205			; not the same (applies only if another directory sector must  
e205			; be read).  
e205			;  
e205 2a c8 e9		NXENTRY:LD      HL,(DIRSIZE)    ;get directory entry size limit.  
e208 eb			        EX      DE,HL  
e209 2a ea e9		        LD      HL,(FILEPOS)    ;get current count.  
e20c 23			        INC     HL              ;go on to the next one.  
e20d 22 ea e9		        LD      (FILEPOS),HL  
e210 cd 95 e1		        CALL    SUBHL           ;(HL)=(DIRSIZE)-(FILEPOS)  
e213 d2 19 e2		        JP      NC,NXENT1       ;is there more room left?  
e216 c3 fe e1		        JP      STFILPOS        ;no. Set this flag and return.  
e219 3a ea e9		NXENT1: LD      A,(FILEPOS)     ;get file position within directory.  
e21c e6 03		        AND     03H             ;only look within this sector (only 4 entries fit).  
e21e 06 05		        LD      B,5             ;convert to relative position (32 bytes each).  
e220 87			NXENT2: ADD     A,A             ;note that this is not efficient code.  
e221 05			        DEC     B               ;5 'ADD A's would be better.  
e222 c2 20 e2		        JP      NZ,NXENT2  
e225 32 e9 e9		        LD      (FCBPOS),A      ;save it as position of fcb.  
e228 b7			        OR      A  
e229 c0			        RET     NZ              ;return if we are within buffer.  
e22a c5			        PUSH    BC  
e22b cd c3 df		        CALL    TRKSEC          ;we need the next directory sector.  
e22e cd d4 e1		        CALL    DIRREAD  
e231 c1			        POP     BC  
e232 c3 9e e1		        JP      CHECKDIR  
e235			;  
e235			;   Routine to to get a bit from the disk space allocation  
e235			; map. It is returned in (A), bit position 0. On entry to here,  
e235			; set (BC) to the block number on the disk to check.  
e235			; On return, (D) will contain the original bit position for  
e235			; this block number and (HL) will point to the address for it.  
e235			;  
e235 79			CKBITMAP: LD    A,C             ;determine bit number of interest.  
e236 e6 07		        AND     07H             ;compute (D)=(E)=(C and 7)+1.  
e238 3c			        INC     A  
e239 5f			        LD      E,A             ;save particular bit number.  
e23a 57			        LD      D,A  
e23b			;  
e23b			;   compute (BC)=(BC)/8.  
e23b			;  
e23b 79			        LD      A,C  
e23c 0f			        RRCA                    ;now shift right 3 bits.  
e23d 0f			        RRCA      
e23e 0f			        RRCA      
e23f e6 1f		        AND     1FH             ;and clear bits 7,6,5.  
e241 4f			        LD      C,A  
e242 78			        LD      A,B  
e243 87			        ADD     A,A             ;now shift (B) into bits 7,6,5.  
e244 87			        ADD     A,A  
e245 87			        ADD     A,A  
e246 87			        ADD     A,A  
e247 87			        ADD     A,A  
e248 b1			        OR      C               ;and add in (C).  
e249 4f			        LD      C,A             ;ok, (C) ha been completed.  
e24a 78			        LD      A,B             ;is there a better way of doing this?  
e24b 0f			        RRCA      
e24c 0f			        RRCA      
e24d 0f			        RRCA      
e24e e6 1f		        AND     1FH  
e250 47			        LD      B,A             ;and now (B) is completed.  
e251			;  
e251			;   use this as an offset into the disk space allocation  
e251			; table.  
e251			;  
e251 2a bf e9		        LD      HL,(ALOCVECT)  
e254 09			        ADD     HL,BC  
e255 7e			        LD      A,(HL)          ;now get correct byte.  
e256 07			CKBMAP1:RLCA                    ;get correct bit into position 0.  
e257 1d			        DEC     E  
e258 c2 56 e2		        JP      NZ,CKBMAP1  
e25b c9			        RET       
e25c			;  
e25c			;   Set or clear the bit map such that block number (BC) will be marked  
e25c			; as used. On entry, if (E)=0 then this bit will be cleared, if it equals  
e25c			; 1 then it will be set (don't use anyother values).  
e25c			;  
e25c d5			STBITMAP: PUSH  DE  
e25d cd 35 e2		        CALL    CKBITMAP        ;get the byte of interest.  
e260 e6 fe		        AND     0FEH            ;clear the affected bit.  
e262 c1			        POP     BC  
e263 b1			        OR      C               ;and now set it acording to (C).  
e264			;  
e264			;  entry to restore the original bit position and then store  
e264			; in table. (A) contains the value, (D) contains the bit  
e264			; position (1-8), and (HL) points to the address within the  
e264			; space allocation table for this byte.  
e264			;  
e264 0f			STBMAP1:RRCA                    ;restore original bit position.  
e265 15			        DEC     D  
e266 c2 64 e2		        JP      NZ,STBMAP1  
e269 77			        LD      (HL),A          ;and stor byte in table.  
e26a c9			        RET       
e26b			;  
e26b			;   Set/clear space used bits in allocation map for this file.  
e26b			; On entry, (C)=1 to set the map and (C)=0 to clear it.  
e26b			;  
e26b cd 5e e1		SETFILE:CALL    FCB2HL          ;get address of fcb  
e26e 11 10 00		        LD      DE,16  
e271 19			        ADD     HL,DE           ;get to block number bytes.  
e272 c5			        PUSH    BC  
e273 0e 11		        LD      C,17            ;check all 17 bytes (max) of table.  
e275 d1			SETFL1: POP     DE  
e276 0d			        DEC     C               ;done all bytes yet?  
e277 c8			        RET     Z  
e278 d5			        PUSH    DE  
e279 3a dd e9		        LD      A,(BIGDISK)     ;check disk size for 16 bit block numbers.  
e27c b7			        OR      A  
e27d ca 88 e2		        JP      Z,SETFL2  
e280 c5			        PUSH    BC              ;only 8 bit numbers. set (BC) to this one.  
e281 e5			        PUSH    HL  
e282 4e			        LD      C,(HL)          ;get low byte from table, always  
e283 06 00		        LD      B,0             ;set high byte to zero.  
e285 c3 8e e2		        JP      SETFL3  
e288 0d			SETFL2: DEC     C               ;for 16 bit block numbers, adjust counter.  
e289 c5			        PUSH    BC  
e28a 4e			        LD      C,(HL)          ;now get both the low and high bytes.  
e28b 23			        INC     HL  
e28c 46			        LD      B,(HL)  
e28d e5			        PUSH    HL  
e28e 79			SETFL3: LD      A,C             ;block used?  
e28f b0			        OR      B  
e290 ca 9d e2		        JP      Z,SETFL4  
e293 2a c6 e9		        LD      HL,(DSKSIZE)    ;is this block number within the  
e296 7d			        LD      A,L             ;space on the disk?  
e297 91			        SUB     C  
e298 7c			        LD      A,H  
e299 98			        SBC     A,B  
e29a d4 5c e2		        CALL    NC,STBITMAP     ;yes, set the proper bit.  
e29d e1			SETFL4: POP     HL              ;point to next block number in fcb.  
e29e 23			        INC     HL  
e29f c1			        POP     BC  
e2a0 c3 75 e2		        JP      SETFL1  
e2a3			;  
e2a3			;   Construct the space used allocation bit map for the active  
e2a3			; drive. If a file name starts with '$' and it is under the  
e2a3			; current user number, then (STATUS) is set to minus 1. Otherwise  
e2a3			; it is not set at all.  
e2a3			;  
e2a3 2a c6 e9		BITMAP: LD      HL,(DSKSIZE)    ;compute size of allocation table.  
e2a6 0e 03		        LD      C,3  
e2a8 cd ea e0		        CALL    SHIFTR          ;(HL)=(HL)/8.  
e2ab 23			        INC     HL              ;at lease 1 byte.  
e2ac 44			        LD      B,H  
e2ad 4d			        LD      C,L             ;set (BC) to the allocation table length.  
e2ae			;  
e2ae			;   Initialize the bitmap for this drive. Right now, the first  
e2ae			; two bytes are specified by the disk parameter block. However  
e2ae			; a patch could be entered here if it were necessary to setup  
e2ae			; this table in a special mannor. For example, the bios could  
e2ae			; determine locations of 'bad blocks' and set them as already  
e2ae			; 'used' in the map.  
e2ae			;  
e2ae 2a bf e9		        LD      HL,(ALOCVECT)   ;now zero out the table now.  
e2b1 36 00		BITMAP1:LD      (HL),0  
e2b3 23			        INC     HL  
e2b4 0b			        DEC     BC  
e2b5 78			        LD      A,B  
e2b6 b1			        OR      C  
e2b7 c2 b1 e2		        JP      NZ,BITMAP1  
e2ba 2a ca e9		        LD      HL,(ALLOC0)     ;get initial space used by directory.  
e2bd eb			        EX      DE,HL  
e2be 2a bf e9		        LD      HL,(ALOCVECT)   ;and put this into map.  
e2c1 73			        LD      (HL),E  
e2c2 23			        INC     HL  
e2c3 72			        LD      (HL),D  
e2c4			;  
e2c4			;   End of initialization portion.  
e2c4			;  
e2c4 cd a1 df		        CALL    HOMEDRV         ;now home the drive.  
e2c7 2a b3 e9		        LD      HL,(SCRATCH1)  
e2ca 36 03		        LD      (HL),3          ;force next directory request to read  
e2cc 23			        INC     HL              ;in a sector.  
e2cd 36 00		        LD      (HL),0  
e2cf cd fe e1		        CALL    STFILPOS        ;clear initial file position also.  
e2d2 0e ff		BITMAP2:LD      C,0FFH          ;read next file name in directory  
e2d4 cd 05 e2		        CALL    NXENTRY         ;and set checksum byte.  
e2d7 cd f5 e1		        CALL    CKFILPOS        ;is there another file?  
e2da c8			        RET     Z  
e2db cd 5e e1		        CALL    FCB2HL          ;yes, get its address.  
e2de 3e e5		        LD      A,0E5H  
e2e0 be			        CP      (HL)            ;empty file entry?  
e2e1 ca d2 e2		        JP      Z,BITMAP2  
e2e4 3a 41 df		        LD      A,(USERNO)      ;no, correct user number?  
e2e7 be			        CP      (HL)  
e2e8 c2 f6 e2		        JP      NZ,BITMAP3  
e2eb 23			        INC     HL  
e2ec 7e			        LD      A,(HL)          ;yes, does name start with a '$'?  
e2ed d6 24		        SUB     '$'  
e2ef c2 f6 e2		        JP      NZ,BITMAP3  
e2f2 3d			        DEC     A               ;yes, set atatus to minus one.  
e2f3 32 45 df		        LD      (STATUS),A  
e2f6 0e 01		BITMAP3:LD      C,1             ;now set this file's space as used in bit map.  
e2f8 cd 6b e2		        CALL    SETFILE  
e2fb cd 8c e1		        CALL    CHKNMBR         ;keep (SCRATCH1) in bounds.  
e2fe c3 d2 e2		        JP      BITMAP2  
e301			;  
e301			;   Set the status (STATUS) and return.  
e301			;  
e301 3a d4 e9		STSTATUS: LD    A,(FNDSTAT)  
e304 c3 01 df		        JP      SETSTAT  
e307			;  
e307			;   Check extents in (A) and (C). Set the zero flag if they  
e307			; are the same. The number of 16k chunks of disk space that  
e307			; the directory extent covers is expressad is (EXTMASK+1).  
e307			; No registers are modified.  
e307			;  
e307 c5			SAMEXT: PUSH    BC  
e308 f5			        PUSH    AF  
e309 3a c5 e9		        LD      A,(EXTMASK)     ;get extent mask and use it to  
e30c 2f			        CPL                     ;to compare both extent numbers.  
e30d 47			        LD      B,A             ;save resulting mask here.  
e30e 79			        LD      A,C             ;mask first extent and save in (C).  
e30f a0			        AND     B  
e310 4f			        LD      C,A  
e311 f1			        POP     AF              ;now mask second extent and compare  
e312 a0			        AND     B               ;with the first one.  
e313 91			        SUB     C  
e314 e6 1f		        AND     1FH             ;(* only check buts 0-4 *)  
e316 c1			        POP     BC              ;the zero flag is set if they are the same.  
e317 c9			        RET                     ;restore (BC) and return.  
e318			;  
e318			;   Search for the first occurence of a file name. On entry,  
e318			; register (C) should contain the number of bytes of the fcb  
e318			; that must match.  
e318			;  
e318 3e ff		FINDFST:LD      A,0FFH  
e31a 32 d4 e9		        LD      (FNDSTAT),A  
e31d 21 d8 e9		        LD      HL,COUNTER      ;save character count.  
e320 71			        LD      (HL),C  
e321 2a 43 df		        LD      HL,(PARAMS)     ;get filename to match.  
e324 22 d9 e9		        LD      (SAVEFCB),HL    ;and save.  
e327 cd fe e1		        CALL    STFILPOS        ;clear initial file position (set to 0ffffh).  
e32a cd a1 df		        CALL    HOMEDRV         ;home the drive.  
e32d			;  
e32d			;   Entry to locate the next occurence of a filename within the  
e32d			; directory. The disk is not expected to have been changed. If  
e32d			; it was, then it will be write protected.  
e32d			;  
e32d 0e 00		FINDNXT:LD      C,0             ;write protect the disk if changed.  
e32f cd 05 e2		        CALL    NXENTRY         ;get next filename entry in directory.  
e332 cd f5 e1		        CALL    CKFILPOS        ;is file position = 0ffffh?  
e335 ca 94 e3		        JP      Z,FNDNXT6       ;yes, exit now then.  
e338 2a d9 e9		        LD      HL,(SAVEFCB)    ;set (DE) pointing to filename to match.  
e33b eb			        EX      DE,HL  
e33c 1a			        LD      A,(DE)  
e33d fe e5		        CP      0E5H            ;empty directory entry?  
e33f ca 4a e3		        JP      Z,FNDNXT1       ;(* are we trying to reserect erased entries? *)  
e342 d5			        PUSH    DE  
e343 cd 7f e1		        CALL    MOREFLS         ;more files in directory?  
e346 d1			        POP     DE  
e347 d2 94 e3		        JP      NC,FNDNXT6      ;no more. Exit now.  
e34a cd 5e e1		FNDNXT1:CALL    FCB2HL          ;get address of this fcb in directory.  
e34d 3a d8 e9		        LD      A,(COUNTER)     ;get number of bytes (characters) to check.  
e350 4f			        LD      C,A  
e351 06 00		        LD      B,0             ;initialize byte position counter.  
e353 79			FNDNXT2:LD      A,C             ;are we done with the compare?  
e354 b7			        OR      A  
e355 ca 83 e3		        JP      Z,FNDNXT5  
e358 1a			        LD      A,(DE)          ;no, check next byte.  
e359 fe 3f		        CP      '?'             ;don't care about this character?  
e35b ca 7c e3		        JP      Z,FNDNXT4  
e35e 78			        LD      A,B             ;get bytes position in fcb.  
e35f fe 0d		        CP      13              ;don't care about the thirteenth byte either.  
e361 ca 7c e3		        JP      Z,FNDNXT4  
e364 fe 0c		        CP      12              ;extent byte?  
e366 1a			        LD      A,(DE)  
e367 ca 73 e3		        JP      Z,FNDNXT3  
e36a 96			        SUB     (HL)            ;otherwise compare characters.  
e36b e6 7f		        AND     7FH  
e36d c2 2d e3		        JP      NZ,FINDNXT      ;not the same, check next entry.  
e370 c3 7c e3		        JP      FNDNXT4         ;so far so good, keep checking.  
e373 c5			FNDNXT3:PUSH    BC              ;check the extent byte here.  
e374 4e			        LD      C,(HL)  
e375 cd 07 e3		        CALL    SAMEXT  
e378 c1			        POP     BC  
e379 c2 2d e3		        JP      NZ,FINDNXT      ;not the same, look some more.  
e37c			;  
e37c			;   So far the names compare. Bump pointers to the next byte  
e37c			; and continue until all (C) characters have been checked.  
e37c			;  
e37c 13			FNDNXT4:INC     DE              ;bump pointers.  
e37d 23			        INC     HL  
e37e 04			        INC     B  
e37f 0d			        DEC     C               ;adjust character counter.  
e380 c3 53 e3		        JP      FNDNXT2  
e383 3a ea e9		FNDNXT5:LD      A,(FILEPOS)     ;return the position of this entry.  
e386 e6 03		        AND     03H  
e388 32 45 df		        LD      (STATUS),A  
e38b 21 d4 e9		        LD      HL,FNDSTAT  
e38e 7e			        LD      A,(HL)  
e38f 17			        RLA       
e390 d0			        RET     NC  
e391 af			        XOR     A  
e392 77			        LD      (HL),A  
e393 c9			        RET       
e394			;  
e394			;   Filename was not found. Set appropriate status.  
e394			;  
e394 cd fe e1		FNDNXT6:CALL    STFILPOS        ;set (FILEPOS) to 0ffffh.  
e397 3e ff		        LD      A,0FFH          ;say not located.  
e399 c3 01 df		        JP      SETSTAT  
e39c			;  
e39c			;   Erase files from the directory. Only the first byte of the  
e39c			; fcb will be affected. It is set to (E5).  
e39c			;  
e39c cd 54 e1		ERAFILE:CALL    CHKWPRT         ;is disk write protected?  
e39f 0e 0c		        LD      C,12            ;only compare file names.  
e3a1 cd 18 e3		        CALL    FINDFST         ;get first file name.  
e3a4 cd f5 e1		ERAFIL1:CALL    CKFILPOS        ;any found?  
e3a7 c8			        RET     Z               ;nope, we must be done.  
e3a8 cd 44 e1		        CALL    CHKROFL         ;is file read only?  
e3ab cd 5e e1		        CALL    FCB2HL          ;nope, get address of fcb and  
e3ae 36 e5		        LD      (HL),0E5H       ;set first byte to 'empty'.  
e3b0 0e 00		        LD      C,0             ;clear the space from the bit map.  
e3b2 cd 6b e2		        CALL    SETFILE  
e3b5 cd c6 e1		        CALL    DIRWRITE        ;now write the directory sector back out.  
e3b8 cd 2d e3		        CALL    FINDNXT         ;find the next file name.  
e3bb c3 a4 e3		        JP      ERAFIL1         ;and repeat process.  
e3be			;  
e3be			;   Look through the space allocation map (bit map) for the  
e3be			; next available block. Start searching at block number (BC-1).  
e3be			; The search procedure is to look for an empty block that is  
e3be			; before the starting block. If not empty, look at a later  
e3be			; block number. In this way, we return the closest empty block  
e3be			; on either side of the 'target' block number. This will speed  
e3be			; access on random devices. For serial devices, this should be  
e3be			; changed to look in the forward direction first and then start  
e3be			; at the front and search some more.  
e3be			;  
e3be			;   On return, (DE)= block number that is empty and (HL) =0  
e3be			; if no empry block was found.  
e3be			;  
e3be 50			FNDSPACE: LD    D,B             ;set (DE) as the block that is checked.  
e3bf 59			        LD      E,C  
e3c0			;  
e3c0			;   Look before target block. Registers (BC) are used as the lower  
e3c0			; pointer and (DE) as the upper pointer.  
e3c0			;  
e3c0 79			FNDSPA1:LD      A,C             ;is block 0 specified?  
e3c1 b0			        OR      B  
e3c2 ca d1 e3		        JP      Z,FNDSPA2  
e3c5 0b			        DEC     BC              ;nope, check previous block.  
e3c6 d5			        PUSH    DE  
e3c7 c5			        PUSH    BC  
e3c8 cd 35 e2		        CALL    CKBITMAP  
e3cb 1f			        RRA                     ;is this block empty?  
e3cc d2 ec e3		        JP      NC,FNDSPA3      ;yes. use this.  
e3cf			;  
e3cf			;   Note that the above logic gets the first block that it finds  
e3cf			; that is empty. Thus a file could be written 'backward' making  
e3cf			; it very slow to access. This could be changed to look for the  
e3cf			; first empty block and then continue until the start of this  
e3cf			; empty space is located and then used that starting block.  
e3cf			; This should help speed up access to some files especially on  
e3cf			; a well used disk with lots of fairly small 'holes'.  
e3cf			;  
e3cf c1			        POP     BC              ;nope, check some more.  
e3d0 d1			        POP     DE  
e3d1			;  
e3d1			;   Now look after target block.  
e3d1			;  
e3d1 2a c6 e9		FNDSPA2:LD      HL,(DSKSIZE)    ;is block (DE) within disk limits?  
e3d4 7b			        LD      A,E  
e3d5 95			        SUB     L  
e3d6 7a			        LD      A,D  
e3d7 9c			        SBC     A,H  
e3d8 d2 f4 e3		        JP      NC,FNDSPA4  
e3db 13			        INC     DE              ;yes, move on to next one.  
e3dc c5			        PUSH    BC  
e3dd d5			        PUSH    DE  
e3de 42			        LD      B,D  
e3df 4b			        LD      C,E  
e3e0 cd 35 e2		        CALL    CKBITMAP        ;check it.  
e3e3 1f			        RRA                     ;empty?  
e3e4 d2 ec e3		        JP      NC,FNDSPA3  
e3e7 d1			        POP     DE              ;nope, continue searching.  
e3e8 c1			        POP     BC  
e3e9 c3 c0 e3		        JP      FNDSPA1  
e3ec			;  
e3ec			;   Empty block found. Set it as used and return with (HL)  
e3ec			; pointing to it (true?).  
e3ec			;  
e3ec 17			FNDSPA3:RLA                     ;reset byte.  
e3ed 3c			        INC     A               ;and set bit 0.  
e3ee cd 64 e2		        CALL    STBMAP1         ;update bit map.  
e3f1 e1			        POP     HL              ;set return registers.  
e3f2 d1			        POP     DE  
e3f3 c9			        RET       
e3f4			;  
e3f4			;   Free block was not found. If (BC) is not zero, then we have  
e3f4			; not checked all of the disk space.  
e3f4			;  
e3f4 79			FNDSPA4:LD      A,C  
e3f5 b0			        OR      B  
e3f6 c2 c0 e3		        JP      NZ,FNDSPA1  
e3f9 21 00 00		        LD      HL,0            ;set 'not found' status.  
e3fc c9			        RET       
e3fd			;  
e3fd			;   Move a complete fcb entry into the directory and write it.  
e3fd			;  
e3fd 0e 00		FCBSET: LD      C,0  
e3ff 1e 20		        LD      E,32            ;length of each entry.  
e401			;  
e401			;   Move (E) bytes from the fcb pointed to by (PARAMS) into  
e401			; fcb in directory starting at relative byte (C). This updated  
e401			; directory buffer is then written to the disk.  
e401			;  
e401 d5			UPDATE: PUSH    DE  
e402 06 00		        LD      B,0             ;set (BC) to relative byte position.  
e404 2a 43 df		        LD      HL,(PARAMS)     ;get address of fcb.  
e407 09			        ADD     HL,BC           ;compute starting byte.  
e408 eb			        EX      DE,HL  
e409 cd 5e e1		        CALL    FCB2HL          ;get address of fcb to update in directory.  
e40c c1			        POP     BC              ;set (C) to number of bytes to change.  
e40d cd 4f df		        CALL    DE2HL  
e410 cd c3 df		UPDATE1:CALL    TRKSEC          ;determine the track and sector affected.  
e413 c3 c6 e1		        JP      DIRWRITE        ;then write this sector out.  
e416			;  
e416			;   Routine to change the name of all files on the disk with a  
e416			; specified name. The fcb contains the current name as the  
e416			; first 12 characters and the new name 16 bytes into the fcb.  
e416			;  
e416 cd 54 e1		CHGNAMES: CALL  CHKWPRT         ;check for a write protected disk.  
e419 0e 0c		        LD      C,12            ;match first 12 bytes of fcb only.  
e41b cd 18 e3		        CALL    FINDFST         ;get first name.  
e41e 2a 43 df		        LD      HL,(PARAMS)     ;get address of fcb.  
e421 7e			        LD      A,(HL)          ;get user number.  
e422 11 10 00		        LD      DE,16           ;move over to desired name.  
e425 19			        ADD     HL,DE  
e426 77			        LD      (HL),A          ;keep same user number.  
e427 cd f5 e1		CHGNAM1:CALL    CKFILPOS        ;any matching file found?  
e42a c8			        RET     Z               ;no, we must be done.  
e42b cd 44 e1		        CALL    CHKROFL         ;check for read only file.  
e42e 0e 10		        LD      C,16            ;start 16 bytes into fcb.  
e430 1e 0c		        LD      E,12            ;and update the first 12 bytes of directory.  
e432 cd 01 e4		        CALL    UPDATE  
e435 cd 2d e3		        CALL    FINDNXT         ;get te next file name.  
e438 c3 27 e4		        JP      CHGNAM1         ;and continue.  
e43b			;  
e43b			;   Update a files attributes. The procedure is to search for  
e43b			; every file with the same name as shown in fcb (ignoring bit 7)  
e43b			; and then to update it (which includes bit 7). No other changes  
e43b			; are made.  
e43b			;  
e43b 0e 0c		SAVEATTR: LD    C,12            ;match first 12 bytes.  
e43d cd 18 e3		        CALL    FINDFST         ;look for first filename.  
e440 cd f5 e1		SAVATR1:CALL    CKFILPOS        ;was one found?  
e443 c8			        RET     Z               ;nope, we must be done.  
e444 0e 00		        LD      C,0             ;yes, update the first 12 bytes now.  
e446 1e 0c		        LD      E,12  
e448 cd 01 e4		        CALL    UPDATE          ;update filename and write directory.  
e44b cd 2d e3		        CALL    FINDNXT         ;and get the next file.  
e44e c3 40 e4		        JP      SAVATR1         ;then continue until done.  
e451			;  
e451			;  Open a file (name specified in fcb).  
e451			;  
e451 0e 0f		OPENIT: LD      C,15            ;compare the first 15 bytes.  
e453 cd 18 e3		        CALL    FINDFST         ;get the first one in directory.  
e456 cd f5 e1		        CALL    CKFILPOS        ;any at all?  
e459 c8			        RET     Z  
e45a cd a6 e0		OPENIT1:CALL    SETEXT          ;point to extent byte within users fcb.  
e45d 7e			        LD      A,(HL)          ;and get it.  
e45e f5			        PUSH    AF              ;save it and address.  
e45f e5			        PUSH    HL  
e460 cd 5e e1		        CALL    FCB2HL          ;point to fcb in directory.  
e463 eb			        EX      DE,HL  
e464 2a 43 df		        LD      HL,(PARAMS)     ;this is the users copy.  
e467 0e 20		        LD      C,32            ;move it into users space.  
e469 d5			        PUSH    DE  
e46a cd 4f df		        CALL    DE2HL  
e46d cd 78 e1		        CALL    SETS2B7         ;set bit 7 in 's2' byte (unmodified).  
e470 d1			        POP     DE              ;now get the extent byte from this fcb.  
e471 21 0c 00		        LD      HL,12  
e474 19			        ADD     HL,DE  
e475 4e			        LD      C,(HL)          ;into (C).  
e476 21 0f 00		        LD      HL,15           ;now get the record count byte into (B).  
e479 19			        ADD     HL,DE  
e47a 46			        LD      B,(HL)  
e47b e1			        POP     HL              ;keep the same extent as the user had originally.  
e47c f1			        POP     AF  
e47d 77			        LD      (HL),A  
e47e 79			        LD      A,C             ;is it the same as in the directory fcb?  
e47f be			        CP      (HL)  
e480 78			        LD      A,B             ;if yes, then use the same record count.  
e481 ca 8b e4		        JP      Z,OPENIT2  
e484 3e 00		        LD      A,0             ;if the user specified an extent greater than  
e486 da 8b e4		        JP      C,OPENIT2       ;the one in the directory, then set record count to 0.  
e489 3e 80		        LD      A,128           ;otherwise set to maximum.  
e48b 2a 43 df		OPENIT2:LD      HL,(PARAMS)     ;set record count in users fcb to (A).  
e48e 11 0f 00		        LD      DE,15  
e491 19			        ADD     HL,DE           ;compute relative position.  
e492 77			        LD      (HL),A          ;and set the record count.  
e493 c9			        RET       
e494			;  
e494			;   Move two bytes from (DE) to (HL) if (and only if) (HL)  
e494			; point to a zero value (16 bit).  
e494			;   Return with zero flag set it (DE) was moved. Registers (DE)  
e494			; and (HL) are not changed. However (A) is.  
e494			;  
e494 7e			MOVEWORD: LD    A,(HL)          ;check for a zero word.  
e495 23			        INC     HL  
e496 b6			        OR      (HL)            ;both bytes zero?  
e497 2b			        DEC     HL  
e498 c0			        RET     NZ              ;nope, just return.  
e499 1a			        LD      A,(DE)          ;yes, move two bytes from (DE) into  
e49a 77			        LD      (HL),A          ;this zero space.  
e49b 13			        INC     DE  
e49c 23			        INC     HL  
e49d 1a			        LD      A,(DE)  
e49e 77			        LD      (HL),A  
e49f 1b			        DEC     DE              ;don't disturb these registers.  
e4a0 2b			        DEC     HL  
e4a1 c9			        RET       
e4a2			;  
e4a2			;   Get here to close a file specified by (fcb).  
e4a2			;  
e4a2 af			CLOSEIT:XOR     A               ;clear status and file position bytes.  
e4a3 32 45 df		        LD      (STATUS),A  
e4a6 32 ea e9		        LD      (FILEPOS),A  
e4a9 32 eb e9		        LD      (FILEPOS+1),A  
e4ac cd 1e e1		        CALL    GETWPRT         ;get write protect bit for this drive.  
e4af c0			        RET     NZ              ;just return if it is set.  
e4b0 cd 69 e1		        CALL    GETS2           ;else get the 's2' byte.  
e4b3 e6 80		        AND     80H             ;and look at bit 7 (file unmodified?).  
e4b5 c0			        RET     NZ              ;just return if set.  
e4b6 0e 0f		        LD      C,15            ;else look up this file in directory.  
e4b8 cd 18 e3		        CALL    FINDFST  
e4bb cd f5 e1		        CALL    CKFILPOS        ;was it found?  
e4be c8			        RET     Z               ;just return if not.  
e4bf 01 10 00		        LD      BC,16           ;set (HL) pointing to records used section.  
e4c2 cd 5e e1		        CALL    FCB2HL  
e4c5 09			        ADD     HL,BC  
e4c6 eb			        EX      DE,HL  
e4c7 2a 43 df		        LD      HL,(PARAMS)     ;do the same for users specified fcb.  
e4ca 09			        ADD     HL,BC  
e4cb 0e 10		        LD      C,16            ;this many bytes are present in this extent.  
e4cd 3a dd e9		CLOSEIT1: LD    A,(BIGDISK)     ;8 or 16 bit record numbers?  
e4d0 b7			        OR      A  
e4d1 ca e8 e4		        JP      Z,CLOSEIT4  
e4d4 7e			        LD      A,(HL)          ;just 8 bit. Get one from users fcb.  
e4d5 b7			        OR      A  
e4d6 1a			        LD      A,(DE)          ;now get one from directory fcb.  
e4d7 c2 db e4		        JP      NZ,CLOSEIT2  
e4da 77			        LD      (HL),A          ;users byte was zero. Update from directory.  
e4db b7			CLOSEIT2: OR    A  
e4dc c2 e1 e4		        JP      NZ,CLOSEIT3  
e4df 7e			        LD      A,(HL)          ;directories byte was zero, update from users fcb.  
e4e0 12			        LD      (DE),A  
e4e1 be			CLOSEIT3: CP    (HL)            ;if neither one of these bytes were zero,  
e4e2 c2 1f e5		        JP      NZ,CLOSEIT7     ;then close error if they are not the same.  
e4e5 c3 fd e4		        JP      CLOSEIT5        ;ok so far, get to next byte in fcbs.  
e4e8 cd 94 e4		CLOSEIT4: CALL  MOVEWORD        ;update users fcb if it is zero.  
e4eb eb			        EX      DE,HL  
e4ec cd 94 e4		        CALL    MOVEWORD        ;update directories fcb if it is zero.  
e4ef eb			        EX      DE,HL  
e4f0 1a			        LD      A,(DE)          ;if these two values are no different,  
e4f1 be			        CP      (HL)            ;then a close error occured.  
e4f2 c2 1f e5		        JP      NZ,CLOSEIT7  
e4f5 13			        INC     DE              ;check second byte.  
e4f6 23			        INC     HL  
e4f7 1a			        LD      A,(DE)  
e4f8 be			        CP      (HL)  
e4f9 c2 1f e5		        JP      NZ,CLOSEIT7  
e4fc 0d			        DEC     C               ;remember 16 bit values.  
e4fd 13			CLOSEIT5: INC   DE              ;bump to next item in table.  
e4fe 23			        INC     HL  
e4ff 0d			        DEC     C               ;there are 16 entries only.  
e500 c2 cd e4		        JP      NZ,CLOSEIT1     ;continue if more to do.  
e503 01 ec ff		        LD      BC,0FFECH       ;backup 20 places (extent byte).  
e506 09			        ADD     HL,BC  
e507 eb			        EX      DE,HL  
e508 09			        ADD     HL,BC  
e509 1a			        LD      A,(DE)  
e50a be			        CP      (HL)            ;directory's extent already greater than the  
e50b da 17 e5		        JP      C,CLOSEIT6      ;users extent?  
e50e 77			        LD      (HL),A          ;no, update directory extent.  
e50f 01 03 00		        LD      BC,3            ;and update the record count byte in  
e512 09			        ADD     HL,BC           ;directories fcb.  
e513 eb			        EX      DE,HL  
e514 09			        ADD     HL,BC  
e515 7e			        LD      A,(HL)          ;get from user.  
e516 12			        LD      (DE),A          ;and put in directory.  
e517 3e ff		CLOSEIT6: LD    A,0FFH          ;set 'was open and is now closed' byte.  
e519 32 d2 e9		        LD      (CLOSEFLG),A  
e51c c3 10 e4		        JP      UPDATE1         ;update the directory now.  
e51f 21 45 df		CLOSEIT7: LD    HL,STATUS       ;set return status and then return.  
e522 35			        DEC     (HL)  
e523 c9			        RET       
e524			;  
e524			;   Routine to get the next empty space in the directory. It  
e524			; will then be cleared for use.  
e524			;  
e524 cd 54 e1		GETEMPTY: CALL  CHKWPRT         ;make sure disk is not write protected.  
e527 2a 43 df		        LD      HL,(PARAMS)     ;save current parameters (fcb).  
e52a e5			        PUSH    HL  
e52b 21 ac e9		        LD      HL,EMPTYFCB     ;use special one for empty space.  
e52e 22 43 df		        LD      (PARAMS),HL  
e531 0e 01		        LD      C,1             ;search for first empty spot in directory.  
e533 cd 18 e3		        CALL    FINDFST         ;(* only check first byte *)  
e536 cd f5 e1		        CALL    CKFILPOS        ;none?  
e539 e1			        POP     HL  
e53a 22 43 df		        LD      (PARAMS),HL     ;restore original fcb address.  
e53d c8			        RET     Z               ;return if no more space.  
e53e eb			        EX      DE,HL  
e53f 21 0f 00		        LD      HL,15           ;point to number of records for this file.  
e542 19			        ADD     HL,DE  
e543 0e 11		        LD      C,17            ;and clear all of this space.  
e545 af			        XOR     A  
e546 77			GETMT1: LD      (HL),A  
e547 23			        INC     HL  
e548 0d			        DEC     C  
e549 c2 46 e5		        JP      NZ,GETMT1  
e54c 21 0d 00		        LD      HL,13           ;clear the 's1' byte also.  
e54f 19			        ADD     HL,DE  
e550 77			        LD      (HL),A  
e551 cd 8c e1		        CALL    CHKNMBR         ;keep (SCRATCH1) within bounds.  
e554 cd fd e3		        CALL    FCBSET          ;write out this fcb entry to directory.  
e557 c3 78 e1		        JP      SETS2B7         ;set 's2' byte bit 7 (unmodified at present).  
e55a			;  
e55a			;   Routine to close the current extent and open the next one  
e55a			; for reading.  
e55a			;  
e55a af			GETNEXT:XOR     A  
e55b 32 d2 e9		        LD      (CLOSEFLG),A    ;clear close flag.  
e55e cd a2 e4		        CALL    CLOSEIT         ;close this extent.  
e561 cd f5 e1		        CALL    CKFILPOS  
e564 c8			        RET     Z               ;not there???  
e565 2a 43 df		        LD      HL,(PARAMS)     ;get extent byte.  
e568 01 0c 00		        LD      BC,12  
e56b 09			        ADD     HL,BC  
e56c 7e			        LD      A,(HL)          ;and increment it.  
e56d 3c			        INC     A  
e56e e6 1f		        AND     1FH             ;keep within range 0-31.  
e570 77			        LD      (HL),A  
e571 ca 83 e5		        JP      Z,GTNEXT1       ;overflow?  
e574 47			        LD      B,A             ;mask extent byte.  
e575 3a c5 e9		        LD      A,(EXTMASK)  
e578 a0			        AND     B  
e579 21 d2 e9		        LD      HL,CLOSEFLG     ;check close flag (0ffh is ok).  
e57c a6			        AND     (HL)  
e57d ca 8e e5		        JP      Z,GTNEXT2       ;if zero, we must read in next extent.  
e580 c3 ac e5		        JP      GTNEXT3         ;else, it is already in memory.  
e583 01 02 00		GTNEXT1:LD      BC,2            ;Point to the 's2' byte.  
e586 09			        ADD     HL,BC  
e587 34			        INC     (HL)            ;and bump it.  
e588 7e			        LD      A,(HL)          ;too many extents?  
e589 e6 0f		        AND     0FH  
e58b ca b6 e5		        JP      Z,GTNEXT5       ;yes, set error code.  
e58e			;  
e58e			;   Get here to open the next extent.  
e58e			;  
e58e 0e 0f		GTNEXT2:LD      C,15            ;set to check first 15 bytes of fcb.  
e590 cd 18 e3		        CALL    FINDFST         ;find the first one.  
e593 cd f5 e1		        CALL    CKFILPOS        ;none available?  
e596 c2 ac e5		        JP      NZ,GTNEXT3  
e599 3a d3 e9		        LD      A,(RDWRTFLG)    ;no extent present. Can we open an empty one?  
e59c 3c			        INC     A               ;0ffh means reading (so not possible).  
e59d ca b6 e5		        JP      Z,GTNEXT5       ;or an error.  
e5a0 cd 24 e5		        CALL    GETEMPTY        ;we are writing, get an empty entry.  
e5a3 cd f5 e1		        CALL    CKFILPOS        ;none?  
e5a6 ca b6 e5		        JP      Z,GTNEXT5       ;error if true.  
e5a9 c3 af e5		        JP      GTNEXT4         ;else we are almost done.  
e5ac cd 5a e4		GTNEXT3:CALL    OPENIT1         ;open this extent.  
e5af cd bb e0		GTNEXT4:CALL    STRDATA         ;move in updated data (rec #, extent #, etc.)  
e5b2 af			        XOR     A               ;clear status and return.  
e5b3 c3 01 df		        JP      SETSTAT  
e5b6			;  
e5b6			;   Error in extending the file. Too many extents were needed  
e5b6			; or not enough space on the disk.  
e5b6			;  
e5b6 cd 05 df		GTNEXT5:CALL    IOERR1          ;set error code, clear bit 7 of 's2'  
e5b9 c3 78 e1		        JP      SETS2B7         ;so this is not written on a close.  
e5bc			;  
e5bc			;   Read a sequential file.  
e5bc			;  
e5bc 3e 01		RDSEQ:  LD      A,1             ;set sequential access mode.  
e5be 32 d5 e9		        LD      (MODE),A  
e5c1 3e ff		RDSEQ1: LD      A,0FFH          ;don't allow reading unwritten space.  
e5c3 32 d3 e9		        LD      (RDWRTFLG),A  
e5c6 cd bb e0		        CALL    STRDATA         ;put rec# and ext# into fcb.  
e5c9 3a e3 e9		        LD      A,(SAVNREC)     ;get next record to read.  
e5cc 21 e1 e9		        LD      HL,SAVNXT       ;get number of records in extent.  
e5cf be			        CP      (HL)            ;within this extent?  
e5d0 da e6 e5		        JP      C,RDSEQ2  
e5d3 fe 80		        CP      128             ;no. Is this extent fully used?  
e5d5 c2 fb e5		        JP      NZ,RDSEQ3       ;no. End-of-file.  
e5d8 cd 5a e5		        CALL    GETNEXT         ;yes, open the next one.  
e5db af			        XOR     A               ;reset next record to read.  
e5dc 32 e3 e9		        LD      (SAVNREC),A  
e5df 3a 45 df		        LD      A,(STATUS)      ;check on open, successful?  
e5e2 b7			        OR      A  
e5e3 c2 fb e5		        JP      NZ,RDSEQ3       ;no, error.  
e5e6 cd 77 e0		RDSEQ2: CALL    COMBLK          ;ok. compute block number to read.  
e5e9 cd 84 e0		        CALL    CHKBLK          ;check it. Within bounds?  
e5ec ca fb e5		        JP      Z,RDSEQ3        ;no, error.  
e5ef cd 8a e0		        CALL    LOGICAL         ;convert (BLKNMBR) to logical sector (128 byte).  
e5f2 cd d1 df		        CALL    TRKSEC1         ;set the track and sector for this block #.  
e5f5 cd b2 df		        CALL    DOREAD          ;and read it.  
e5f8 c3 d2 e0		        JP      SETNREC         ;and set the next record to be accessed.  
e5fb			;  
e5fb			;   Read error occured. Set status and return.  
e5fb			;  
e5fb c3 05 df		RDSEQ3: JP      IOERR1  
e5fe			;  
e5fe			;   Write the next sequential record.  
e5fe			;  
e5fe 3e 01		WTSEQ:  LD      A,1             ;set sequential access mode.  
e600 32 d5 e9		        LD      (MODE),A  
e603 3e 00		WTSEQ1: LD      A,0             ;allow an addition empty extent to be opened.  
e605 32 d3 e9		        LD      (RDWRTFLG),A  
e608 cd 54 e1		        CALL    CHKWPRT         ;check write protect status.  
e60b 2a 43 df		        LD      HL,(PARAMS)  
e60e cd 47 e1		        CALL    CKROF1          ;check for read only file, (HL) already set to fcb.  
e611 cd bb e0		        CALL    STRDATA         ;put updated data into fcb.  
e614 3a e3 e9		        LD      A,(SAVNREC)     ;get record number to write.  
e617 fe 80		        CP      128             ;within range?  
e619 d2 05 df		        JP      NC,IOERR1       ;no, error(?).  
e61c cd 77 e0		        CALL    COMBLK          ;compute block number.  
e61f cd 84 e0		        CALL    CHKBLK          ;check number.  
e622 0e 00		        LD      C,0             ;is there one to write to?  
e624 c2 6e e6		        JP      NZ,WTSEQ6       ;yes, go do it.  
e627 cd 3e e0		        CALL    GETBLOCK        ;get next block number within fcb to use.  
e62a 32 d7 e9		        LD      (RELBLOCK),A    ;and save.  
e62d 01 00 00		        LD      BC,0            ;start looking for space from the start  
e630 b7			        OR      A               ;if none allocated as yet.  
e631 ca 3b e6		        JP      Z,WTSEQ2  
e634 4f			        LD      C,A             ;extract previous block number from fcb  
e635 0b			        DEC     BC              ;so we can be closest to it.  
e636 cd 5e e0		        CALL    EXTBLK  
e639 44			        LD      B,H  
e63a 4d			        LD      C,L  
e63b cd be e3		WTSEQ2: CALL    FNDSPACE        ;find the next empty block nearest number (BC).  
e63e 7d			        LD      A,L             ;check for a zero number.  
e63f b4			        OR      H  
e640 c2 48 e6		        JP      NZ,WTSEQ3  
e643 3e 02		        LD      A,2             ;no more space?  
e645 c3 01 df		        JP      SETSTAT  
e648 22 e5 e9		WTSEQ3: LD      (BLKNMBR),HL    ;save block number to access.  
e64b eb			        EX      DE,HL           ;put block number into (DE).  
e64c 2a 43 df		        LD      HL,(PARAMS)     ;now we must update the fcb for this  
e64f 01 10 00		        LD      BC,16           ;newly allocated block.  
e652 09			        ADD     HL,BC  
e653 3a dd e9		        LD      A,(BIGDISK)     ;8 or 16 bit block numbers?  
e656 b7			        OR      A  
e657 3a d7 e9		        LD      A,(RELBLOCK)    ;(* update this entry *)  
e65a ca 64 e6		        JP      Z,WTSEQ4        ;zero means 16 bit ones.  
e65d cd 64 e1		        CALL    ADDA2HL         ;(HL)=(HL)+(A)  
e660 73			        LD      (HL),E          ;store new block number.  
e661 c3 6c e6		        JP      WTSEQ5  
e664 4f			WTSEQ4: LD      C,A             ;compute spot in this 16 bit table.  
e665 06 00		        LD      B,0  
e667 09			        ADD     HL,BC  
e668 09			        ADD     HL,BC  
e669 73			        LD      (HL),E          ;stuff block number (DE) there.  
e66a 23			        INC     HL  
e66b 72			        LD      (HL),D  
e66c 0e 02		WTSEQ5: LD      C,2             ;set (C) to indicate writing to un-used disk space.  
e66e 3a 45 df		WTSEQ6: LD      A,(STATUS)      ;are we ok so far?  
e671 b7			        OR      A  
e672 c0			        RET     NZ  
e673 c5			        PUSH    BC              ;yes, save write flag for bios (register C).  
e674 cd 8a e0		        CALL    LOGICAL         ;convert (BLKNMBR) over to loical sectors.  
e677 3a d5 e9		        LD      A,(MODE)        ;get access mode flag (1=sequential,  
e67a 3d			        DEC     A               ;0=random, 2=special?).  
e67b 3d			        DEC     A  
e67c c2 bb e6		        JP      NZ,WTSEQ9  
e67f			;  
e67f			;   Special random i/o from function #40. Maybe for M/PM, but the  
e67f			; current block, if it has not been written to, will be zeroed  
e67f			; out and then written (reason?).  
e67f			;  
e67f c1			        POP     BC  
e680 c5			        PUSH    BC  
e681 79			        LD      A,C             ;get write status flag (2=writing unused space).  
e682 3d			        DEC     A  
e683 3d			        DEC     A  
e684 c2 bb e6		        JP      NZ,WTSEQ9  
e687 e5			        PUSH    HL  
e688 2a b9 e9		        LD      HL,(DIRBUF)     ;zero out the directory buffer.  
e68b 57			        LD      D,A             ;note that (A) is zero here.  
e68c 77			WTSEQ7: LD      (HL),A  
e68d 23			        INC     HL  
e68e 14			        INC     D               ;do 128 bytes.  
e68f f2 8c e6		        JP      P,WTSEQ7  
e692 cd e0 e1		        CALL    DIRDMA          ;tell the bios the dma address for directory access.  
e695 2a e7 e9		        LD      HL,(LOGSECT)    ;get sector that starts current block.  
e698 0e 02		        LD      C,2             ;set 'writing to unused space' flag.  
e69a 22 e5 e9		WTSEQ8: LD      (BLKNMBR),HL    ;save sector to write.  
e69d c5			        PUSH    BC  
e69e cd d1 df		        CALL    TRKSEC1         ;determine its track and sector numbers.  
e6a1 c1			        POP     BC  
e6a2 cd b8 df		        CALL    DOWRITE         ;now write out 128 bytes of zeros.  
e6a5 2a e5 e9		        LD      HL,(BLKNMBR)    ;get sector number.  
e6a8 0e 00		        LD      C,0             ;set normal write flag.  
e6aa 3a c4 e9		        LD      A,(BLKMASK)     ;determine if we have written the entire  
e6ad 47			        LD      B,A             ;physical block.  
e6ae a5			        AND     L  
e6af b8			        CP      B  
e6b0 23			        INC     HL              ;prepare for the next one.  
e6b1 c2 9a e6		        JP      NZ,WTSEQ8       ;continue until (BLKMASK+1) sectors written.  
e6b4 e1			        POP     HL              ;reset next sector number.  
e6b5 22 e5 e9		        LD      (BLKNMBR),HL  
e6b8 cd da e1		        CALL    DEFDMA          ;and reset dma address.  
e6bb			;  
e6bb			;   Normal disk write. Set the desired track and sector then  
e6bb			; do the actual write.  
e6bb			;  
e6bb cd d1 df		WTSEQ9: CALL    TRKSEC1         ;determine track and sector for this write.  
e6be c1			        POP     BC              ;get write status flag.  
e6bf c5			        PUSH    BC  
e6c0 cd b8 df		        CALL    DOWRITE         ;and write this out.  
e6c3 c1			        POP     BC  
e6c4 3a e3 e9		        LD      A,(SAVNREC)     ;get number of records in file.  
e6c7 21 e1 e9		        LD      HL,SAVNXT       ;get last record written.  
e6ca be			        CP      (HL)  
e6cb da d2 e6		        JP      C,WTSEQ10  
e6ce 77			        LD      (HL),A          ;we have to update record count.  
e6cf 34			        INC     (HL)  
e6d0 0e 02		        LD      C,2  
e6d2			;  
e6d2			;*   This area has been patched to correct disk update problem  
e6d2			;* when using blocking and de-blocking in the BIOS.  
e6d2			;  
e6d2 00			WTSEQ10:NOP                     ;was 'dcr c'  
e6d3 00			        NOP                     ;was 'dcr c'  
e6d4 21 00 00		        LD      HL,0            ;was 'jnz wtseq99'  
e6d7			;  
e6d7			; *   End of patch.  
e6d7			;  
e6d7 f5			        PUSH    AF  
e6d8 cd 69 e1		        CALL    GETS2           ;set 'extent written to' flag.  
e6db e6 7f		        AND     7FH             ;(* clear bit 7 *)  
e6dd 77			        LD      (HL),A  
e6de f1			        POP     AF              ;get record count for this extent.  
e6df fe 7f		WTSEQ99:CP      127             ;is it full?  
e6e1 c2 00 e7		        JP      NZ,WTSEQ12  
e6e4 3a d5 e9		        LD      A,(MODE)        ;yes, are we in sequential mode?  
e6e7 fe 01		        CP      1  
e6e9 c2 00 e7		        JP      NZ,WTSEQ12  
e6ec cd d2 e0		        CALL    SETNREC         ;yes, set next record number.  
e6ef cd 5a e5		        CALL    GETNEXT         ;and get next empty space in directory.  
e6f2 21 45 df		        LD      HL,STATUS       ;ok?  
e6f5 7e			        LD      A,(HL)  
e6f6 b7			        OR      A  
e6f7 c2 fe e6		        JP      NZ,WTSEQ11  
e6fa 3d			        DEC     A               ;yes, set record count to -1.  
e6fb 32 e3 e9		        LD      (SAVNREC),A  
e6fe 36 00		WTSEQ11:LD      (HL),0          ;clear status.  
e700 c3 d2 e0		WTSEQ12:JP      SETNREC         ;set next record to access.  
e703			;  
e703			;   For random i/o, set the fcb for the desired record number  
e703			; based on the 'r0,r1,r2' bytes. These bytes in the fcb are  
e703			; used as follows:  
e703			;  
e703			;       fcb+35            fcb+34            fcb+33  
e703			;  |     'r-2'      |      'r-1'      |      'r-0'     |  
e703			;  |7             0 | 7             0 | 7             0|  
e703			;  |0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0|  
e703			;  |    overflow   | | extra |  extent   |   record #  |  
e703			;  | ______________| |_extent|__number___|_____________|  
e703			;                     also 's2'  
e703			;  
e703			;   On entry, register (C) contains 0ffh if this is a read  
e703			; and thus we can not access unwritten disk space. Otherwise,  
e703			; another extent will be opened (for writing) if required.  
e703			;  
e703 af			POSITION: XOR   A               ;set random i/o flag.  
e704 32 d5 e9		        LD      (MODE),A  
e707			;  
e707			;   Special entry (function #40). M/PM ?  
e707			;  
e707 c5			POSITN1:PUSH    BC              ;save read/write flag.  
e708 2a 43 df		        LD      HL,(PARAMS)     ;get address of fcb.  
e70b eb			        EX      DE,HL  
e70c 21 21 00		        LD      HL,33           ;now get byte 'r0'.  
e70f 19			        ADD     HL,DE  
e710 7e			        LD      A,(HL)  
e711 e6 7f		        AND     7FH             ;keep bits 0-6 for the record number to access.  
e713 f5			        PUSH    AF  
e714 7e			        LD      A,(HL)          ;now get bit 7 of 'r0' and bits 0-3 of 'r1'.  
e715 17			        RLA       
e716 23			        INC     HL  
e717 7e			        LD      A,(HL)  
e718 17			        RLA       
e719 e6 1f		        AND     1FH             ;and save this in bits 0-4 of (C).  
e71b 4f			        LD      C,A             ;this is the extent byte.  
e71c 7e			        LD      A,(HL)          ;now get the extra extent byte.  
e71d 1f			        RRA       
e71e 1f			        RRA       
e71f 1f			        RRA       
e720 1f			        RRA       
e721 e6 0f		        AND     0FH  
e723 47			        LD      B,A             ;and save it in (B).  
e724 f1			        POP     AF              ;get record number back to (A).  
e725 23			        INC     HL              ;check overflow byte 'r2'.  
e726 6e			        LD      L,(HL)  
e727 2c			        INC     L  
e728 2d			        DEC     L  
e729 2e 06		        LD      L,6             ;prepare for error.  
e72b c2 8b e7		        JP      NZ,POSITN5      ;out of disk space error.  
e72e 21 20 00		        LD      HL,32           ;store record number into fcb.  
e731 19			        ADD     HL,DE  
e732 77			        LD      (HL),A  
e733 21 0c 00		        LD      HL,12           ;and now check the extent byte.  
e736 19			        ADD     HL,DE  
e737 79			        LD      A,C  
e738 96			        SUB     (HL)            ;same extent as before?  
e739 c2 47 e7		        JP      NZ,POSITN2  
e73c 21 0e 00		        LD      HL,14           ;yes, check extra extent byte 's2' also.  
e73f 19			        ADD     HL,DE  
e740 78			        LD      A,B  
e741 96			        SUB     (HL)  
e742 e6 7f		        AND     7FH  
e744 ca 7f e7		        JP      Z,POSITN3       ;same, we are almost done then.  
e747			;  
e747			;  Get here when another extent is required.  
e747			;  
e747 c5			POSITN2:PUSH    BC  
e748 d5			        PUSH    DE  
e749 cd a2 e4		        CALL    CLOSEIT         ;close current extent.  
e74c d1			        POP     DE  
e74d c1			        POP     BC  
e74e 2e 03		        LD      L,3             ;prepare for error.  
e750 3a 45 df		        LD      A,(STATUS)  
e753 3c			        INC     A  
e754 ca 84 e7		        JP      Z,POSITN4       ;close error.  
e757 21 0c 00		        LD      HL,12           ;put desired extent into fcb now.  
e75a 19			        ADD     HL,DE  
e75b 71			        LD      (HL),C  
e75c 21 0e 00		        LD      HL,14           ;and store extra extent byte 's2'.  
e75f 19			        ADD     HL,DE  
e760 70			        LD      (HL),B  
e761 cd 51 e4		        CALL    OPENIT          ;try and get this extent.  
e764 3a 45 df		        LD      A,(STATUS)      ;was it there?  
e767 3c			        INC     A  
e768 c2 7f e7		        JP      NZ,POSITN3  
e76b c1			        POP     BC              ;no. can we create a new one (writing?).  
e76c c5			        PUSH    BC  
e76d 2e 04		        LD      L,4             ;prepare for error.  
e76f 0c			        INC     C  
e770 ca 84 e7		        JP      Z,POSITN4       ;nope, reading unwritten space error.  
e773 cd 24 e5		        CALL    GETEMPTY        ;yes we can, try to find space.  
e776 2e 05		        LD      L,5             ;prepare for error.  
e778 3a 45 df		        LD      A,(STATUS)  
e77b 3c			        INC     A  
e77c ca 84 e7		        JP      Z,POSITN4       ;out of space?  
e77f			;  
e77f			;   Normal return location. Clear error code and return.  
e77f			;  
e77f c1			POSITN3:POP     BC              ;restore stack.  
e780 af			        XOR     A               ;and clear error code byte.  
e781 c3 01 df		        JP      SETSTAT  
e784			;  
e784			;   Error. Set the 's2' byte to indicate this (why?).  
e784			;  
e784 e5			POSITN4:PUSH    HL  
e785 cd 69 e1		        CALL    GETS2  
e788 36 c0		        LD      (HL),0C0H  
e78a e1			        POP     HL  
e78b			;  
e78b			;   Return with error code (presently in L).  
e78b			;  
e78b c1			POSITN5:POP     BC  
e78c 7d			        LD      A,L             ;get error code.  
e78d 32 45 df		        LD      (STATUS),A  
e790 c3 78 e1		        JP      SETS2B7  
e793			;  
e793			;   Read a random record.  
e793			;  
e793 0e ff		READRAN:LD      C,0FFH          ;set 'read' status.  
e795 cd 03 e7		        CALL    POSITION        ;position the file to proper record.  
e798 cc c1 e5		        CALL    Z,RDSEQ1        ;and read it as usual (if no errors).  
e79b c9			        RET       
e79c			;  
e79c			;   Write to a random record.  
e79c			;  
e79c 0e 00		WRITERAN: LD    C,0             ;set 'writing' flag.  
e79e cd 03 e7		        CALL    POSITION        ;position the file to proper record.  
e7a1 cc 03 e6		        CALL    Z,WTSEQ1        ;and write as usual (if no errors).  
e7a4 c9			        RET       
e7a5			;  
e7a5			;   Compute the random record number. Enter with (HL) pointing  
e7a5			; to a fcb an (DE) contains a relative location of a record  
e7a5			; number. On exit, (C) contains the 'r0' byte, (B) the 'r1'  
e7a5			; byte, and (A) the 'r2' byte.  
e7a5			;  
e7a5			;   On return, the zero flag is set if the record is within  
e7a5			; bounds. Otherwise, an overflow occured.  
e7a5			;  
e7a5 eb			COMPRAND: EX    DE,HL           ;save fcb pointer in (DE).  
e7a6 19			        ADD     HL,DE           ;compute relative position of record #.  
e7a7 4e			        LD      C,(HL)          ;get record number into (BC).  
e7a8 06 00		        LD      B,0  
e7aa 21 0c 00		        LD      HL,12           ;now get extent.  
e7ad 19			        ADD     HL,DE  
e7ae 7e			        LD      A,(HL)          ;compute (BC)=(record #)+(extent)*128.  
e7af 0f			        RRCA                    ;move lower bit into bit 7.  
e7b0 e6 80		        AND     80H             ;and ignore all other bits.  
e7b2 81			        ADD     A,C             ;add to our record number.  
e7b3 4f			        LD      C,A  
e7b4 3e 00		        LD      A,0             ;take care of any carry.  
e7b6 88			        ADC     A,B  
e7b7 47			        LD      B,A  
e7b8 7e			        LD      A,(HL)          ;now get the upper bits of extent into  
e7b9 0f			        RRCA                    ;bit positions 0-3.  
e7ba e6 0f		        AND     0FH             ;and ignore all others.  
e7bc 80			        ADD     A,B             ;add this in to 'r1' byte.  
e7bd 47			        LD      B,A  
e7be 21 0e 00		        LD      HL,14           ;get the 's2' byte (extra extent).  
e7c1 19			        ADD     HL,DE  
e7c2 7e			        LD      A,(HL)  
e7c3 87			        ADD     A,A             ;and shift it left 4 bits (bits 4-7).  
e7c4 87			        ADD     A,A  
e7c5 87			        ADD     A,A  
e7c6 87			        ADD     A,A  
e7c7 f5			        PUSH    AF              ;save carry flag (bit 0 of flag byte).  
e7c8 80			        ADD     A,B             ;now add extra extent into 'r1'.  
e7c9 47			        LD      B,A  
e7ca f5			        PUSH    AF              ;and save carry (overflow byte 'r2').  
e7cb e1			        POP     HL              ;bit 0 of (L) is the overflow indicator.  
e7cc 7d			        LD      A,L  
e7cd e1			        POP     HL              ;and same for first carry flag.  
e7ce b5			        OR      L               ;either one of these set?  
e7cf e6 01		        AND     01H             ;only check the carry flags.  
e7d1 c9			        RET       
e7d2			;  
e7d2			;   Routine to setup the fcb (bytes 'r0', 'r1', 'r2') to  
e7d2			; reflect the last record used for a random (or other) file.  
e7d2			; This reads the directory and looks at all extents computing  
e7d2			; the largerst record number for each and keeping the maximum  
e7d2			; value only. Then 'r0', 'r1', and 'r2' will reflect this  
e7d2			; maximum record number. This is used to compute the space used  
e7d2			; by a random file.  
e7d2			;  
e7d2 0e 0c		RANSIZE:LD      C,12            ;look thru directory for first entry with  
e7d4 cd 18 e3		        CALL    FINDFST         ;this name.  
e7d7 2a 43 df		        LD      HL,(PARAMS)     ;zero out the 'r0, r1, r2' bytes.  
e7da 11 21 00		        LD      DE,33  
e7dd 19			        ADD     HL,DE  
e7de e5			        PUSH    HL  
e7df 72			        LD      (HL),D          ;note that (D)=0.  
e7e0 23			        INC     HL  
e7e1 72			        LD      (HL),D  
e7e2 23			        INC     HL  
e7e3 72			        LD      (HL),D  
e7e4 cd f5 e1		RANSIZ1:CALL    CKFILPOS        ;is there an extent to process?  
e7e7 ca 0c e8		        JP      Z,RANSIZ3       ;no, we are done.  
e7ea cd 5e e1		        CALL    FCB2HL          ;set (HL) pointing to proper fcb in dir.  
e7ed 11 0f 00		        LD      DE,15           ;point to last record in extent.  
e7f0 cd a5 e7		        CALL    COMPRAND        ;and compute random parameters.  
e7f3 e1			        POP     HL  
e7f4 e5			        PUSH    HL              ;now check these values against those  
e7f5 5f			        LD      E,A             ;already in fcb.  
e7f6 79			        LD      A,C             ;the carry flag will be set if those  
e7f7 96			        SUB     (HL)            ;in the fcb represent a larger size than  
e7f8 23			        INC     HL              ;this extent does.  
e7f9 78			        LD      A,B  
e7fa 9e			        SBC     A,(HL)  
e7fb 23			        INC     HL  
e7fc 7b			        LD      A,E  
e7fd 9e			        SBC     A,(HL)  
e7fe da 06 e8		        JP      C,RANSIZ2  
e801 73			        LD      (HL),E          ;we found a larger (in size) extent.  
e802 2b			        DEC     HL              ;stuff these values into fcb.  
e803 70			        LD      (HL),B  
e804 2b			        DEC     HL  
e805 71			        LD      (HL),C  
e806 cd 2d e3		RANSIZ2:CALL    FINDNXT         ;now get the next extent.  
e809 c3 e4 e7		        JP      RANSIZ1         ;continue til all done.  
e80c e1			RANSIZ3:POP     HL              ;we are done, restore the stack and  
e80d c9			        RET                     ;return.  
e80e			;  
e80e			;   Function to return the random record position of a given  
e80e			; file which has been read in sequential mode up to now.  
e80e			;  
e80e 2a 43 df		SETRAN: LD      HL,(PARAMS)     ;point to fcb.  
e811 11 20 00		        LD      DE,32           ;and to last used record.  
e814 cd a5 e7		        CALL    COMPRAND        ;compute random position.  
e817 21 21 00		        LD      HL,33           ;now stuff these values into fcb.  
e81a 19			        ADD     HL,DE  
e81b 71			        LD      (HL),C          ;move 'r0'.  
e81c 23			        INC     HL  
e81d 70			        LD      (HL),B          ;and 'r1'.  
e81e 23			        INC     HL  
e81f 77			        LD      (HL),A          ;and lastly 'r2'.  
e820 c9			        RET       
e821			;  
e821			;   This routine select the drive specified in (ACTIVE) and  
e821			; update the login vector and bitmap table if this drive was  
e821			; not already active.  
e821			;  
e821 2a af e9		LOGINDRV: LD    HL,(LOGIN)      ;get the login vector.  
e824 3a 42 df		        LD      A,(ACTIVE)      ;get the default drive.  
e827 4f			        LD      C,A  
e828 cd ea e0		        CALL    SHIFTR          ;position active bit for this drive  
e82b e5			        PUSH    HL              ;into bit 0.  
e82c eb			        EX      DE,HL  
e82d cd 59 df		        CALL    SELECT          ;select this drive.  
e830 e1			        POP     HL  
e831 cc 47 df		        CALL    Z,SLCTERR       ;valid drive?  
e834 7d			        LD      A,L             ;is this a newly activated drive?  
e835 1f			        RRA       
e836 d8			        RET     C  
e837 2a af e9		        LD      HL,(LOGIN)      ;yes, update the login vector.  
e83a 4d			        LD      C,L  
e83b 44			        LD      B,H  
e83c cd 0b e1		        CALL    SETBIT  
e83f 22 af e9		        LD      (LOGIN),HL      ;and save.  
e842 c3 a3 e2		        JP      BITMAP          ;now update the bitmap.  
e845			;  
e845			;   Function to set the active disk number.  
e845			;  
e845 3a d6 e9		SETDSK: LD      A,(EPARAM)      ;get parameter passed and see if this  
e848 21 42 df		        LD      HL,ACTIVE       ;represents a change in drives.  
e84b be			        CP      (HL)  
e84c c8			        RET     Z  
e84d 77			        LD      (HL),A          ;yes it does, log it in.  
e84e c3 21 e8		        JP      LOGINDRV  
e851			;  
e851			;   This is the 'auto disk select' routine. The firsst byte  
e851			; of the fcb is examined for a drive specification. If non  
e851			; zero then the drive will be selected and loged in.  
e851			;  
e851 3e ff		AUTOSEL:LD      A,0FFH          ;say 'auto-select activated'.  
e853 32 de e9		        LD      (AUTO),A  
e856 2a 43 df		        LD      HL,(PARAMS)     ;get drive specified.  
e859 7e			        LD      A,(HL)  
e85a e6 1f		        AND     1FH             ;look at lower 5 bits.  
e85c 3d			        DEC     A               ;adjust for (1=A, 2=B) etc.  
e85d 32 d6 e9		        LD      (EPARAM),A      ;and save for the select routine.  
e860 fe 1e		        CP      1EH             ;check for 'no change' condition.  
e862 d2 75 e8		        JP      NC,AUTOSL1      ;yes, don't change.  
e865 3a 42 df		        LD      A,(ACTIVE)      ;we must change, save currently active  
e868 32 df e9		        LD      (OLDDRV),A      ;drive.  
e86b 7e			        LD      A,(HL)          ;and save first byte of fcb also.  
e86c 32 e0 e9		        LD      (AUTOFLAG),A    ;this must be non-zero.  
e86f e6 e0		        AND     0E0H            ;whats this for (bits 6,7 are used for  
e871 77			        LD      (HL),A          ;something)?  
e872 cd 45 e8		        CALL    SETDSK          ;select and log in this drive.  
e875 3a 41 df		AUTOSL1:LD      A,(USERNO)      ;move user number into fcb.  
e878 2a 43 df		        LD      HL,(PARAMS)     ;(* upper half of first byte *)  
e87b b6			        OR      (HL)  
e87c 77			        LD      (HL),A  
e87d c9			        RET                     ;and return (all done).  
e87e			;  
e87e			;   Function to return the current cp/m version number.  
e87e			;  
e87e 3e 22		GETVER: LD      A,022H          ;version 2.2  
e880 c3 01 df		        JP      SETSTAT  
e883			;  
e883			;   Function to reset the disk system.  
e883			;  
e883 21 00 00		RSTDSK: LD      HL,0            ;clear write protect status and log  
e886 22 ad e9		        LD      (WRTPRT),HL     ;in vector.  
e889 22 af e9		        LD      (LOGIN),HL  
e88c af			        XOR     A               ;select drive 'A'.  
e88d 32 42 df		        LD      (ACTIVE),A  
e890 21 80 00		        LD      HL,TBUFF        ;setup default dma address.  
e893 22 b1 e9		        LD      (USERDMA),HL  
e896 cd da e1		        CALL    DEFDMA  
e899 c3 21 e8		        JP      LOGINDRV        ;now log in drive 'A'.  
e89c			;  
e89c			;   Function to open a specified file.  
e89c			;  
e89c cd 72 e1		OPENFIL:CALL    CLEARS2         ;clear 's2' byte.  
e89f cd 51 e8		        CALL    AUTOSEL         ;select proper disk.  
e8a2 c3 51 e4		        JP      OPENIT          ;and open the file.  
e8a5			;  
e8a5			;   Function to close a specified file.  
e8a5			;  
e8a5 cd 51 e8		CLOSEFIL: CALL  AUTOSEL         ;select proper disk.  
e8a8 c3 a2 e4		        JP      CLOSEIT         ;and close the file.  
e8ab			;  
e8ab			;   Function to return the first occurence of a specified file  
e8ab			; name. If the first byte of the fcb is '?' then the name will  
e8ab			; not be checked (get the first entry no matter what).  
e8ab			;  
e8ab 0e 00		GETFST: LD      C,0             ;prepare for special search.  
e8ad eb			        EX      DE,HL  
e8ae 7e			        LD      A,(HL)          ;is first byte a '?'?  
e8af fe 3f		        CP      '?'  
e8b1 ca c2 e8		        JP      Z,GETFST1       ;yes, just get very first entry (zero length match).  
e8b4 cd a6 e0		        CALL    SETEXT          ;get the extension byte from fcb.  
e8b7 7e			        LD      A,(HL)          ;is it '?'? if yes, then we want  
e8b8 fe 3f		        CP      '?'             ;an entry with a specific 's2' byte.  
e8ba c4 72 e1		        CALL    NZ,CLEARS2      ;otherwise, look for a zero 's2' byte.  
e8bd cd 51 e8		        CALL    AUTOSEL         ;select proper drive.  
e8c0 0e 0f		        LD      C,15            ;compare bytes 0-14 in fcb (12&13 excluded).  
e8c2 cd 18 e3		GETFST1:CALL    FINDFST         ;find an entry and then move it into  
e8c5 c3 e9 e1		        JP      MOVEDIR         ;the users dma space.  
e8c8			;  
e8c8			;   Function to return the next occurence of a file name.  
e8c8			;  
e8c8 2a d9 e9		GETNXT: LD      HL,(SAVEFCB)    ;restore pointers. note that no  
e8cb 22 43 df		        LD      (PARAMS),HL     ;other dbos calls are allowed.  
e8ce cd 51 e8		        CALL    AUTOSEL         ;no error will be returned, but the  
e8d1 cd 2d e3		        CALL    FINDNXT         ;results will be wrong.  
e8d4 c3 e9 e1		        JP      MOVEDIR  
e8d7			;  
e8d7			;   Function to delete a file by name.  
e8d7			;  
e8d7 cd 51 e8		DELFILE:CALL    AUTOSEL         ;select proper drive.  
e8da cd 9c e3		        CALL    ERAFILE         ;erase the file.  
e8dd c3 01 e3		        JP      STSTATUS        ;set status and return.  
e8e0			;  
e8e0			;   Function to execute a sequential read of the specified  
e8e0			; record number.  
e8e0			;  
e8e0 cd 51 e8		READSEQ:CALL    AUTOSEL         ;select proper drive then read.  
e8e3 c3 bc e5		        JP      RDSEQ  
e8e6			;  
e8e6			;   Function to write the net sequential record.  
e8e6			;  
e8e6 cd 51 e8		WRTSEQ: CALL    AUTOSEL         ;select proper drive then write.  
e8e9 c3 fe e5		        JP      WTSEQ  
e8ec			;  
e8ec			;   Create a file function.  
e8ec			;  
e8ec cd 72 e1		FCREATE:CALL    CLEARS2         ;clear the 's2' byte on all creates.  
e8ef cd 51 e8		        CALL    AUTOSEL         ;select proper drive and get the next  
e8f2 c3 24 e5		        JP      GETEMPTY        ;empty directory space.  
e8f5			;  
e8f5			;   Function to rename a file.  
e8f5			;  
e8f5 cd 51 e8		RENFILE:CALL    AUTOSEL         ;select proper drive and then switch  
e8f8 cd 16 e4		        CALL    CHGNAMES        ;file names.  
e8fb c3 01 e3		        JP      STSTATUS  
e8fe			;  
e8fe			;   Function to return the login vector.  
e8fe			;  
e8fe 2a af e9		GETLOG: LD      HL,(LOGIN)  
e901 c3 29 e9		        JP      GETPRM1  
e904			;  
e904			;   Function to return the current disk assignment.  
e904			;  
e904 3a 42 df		GETCRNT:LD      A,(ACTIVE)  
e907 c3 01 df		        JP      SETSTAT  
e90a			;  
e90a			;   Function to set the dma address.  
e90a			;  
e90a eb			PUTDMA: EX      DE,HL  
e90b 22 b1 e9		        LD      (USERDMA),HL    ;save in our space and then get to  
e90e c3 da e1		        JP      DEFDMA          ;the bios with this also.  
e911			;  
e911			;   Function to return the allocation vector.  
e911			;  
e911 2a bf e9		GETALOC:LD      HL,(ALOCVECT)  
e914 c3 29 e9		        JP      GETPRM1  
e917			;  
e917			;   Function to return the read-only status vector.  
e917			;  
e917 2a ad e9		GETROV: LD      HL,(WRTPRT)  
e91a c3 29 e9		        JP      GETPRM1  
e91d			;  
e91d			;   Function to set the file attributes (read-only, system).  
e91d			;  
e91d cd 51 e8		SETATTR:CALL    AUTOSEL         ;select proper drive then save attributes.  
e920 cd 3b e4		        CALL    SAVEATTR  
e923 c3 01 e3		        JP      STSTATUS  
e926			;  
e926			;   Function to return the address of the disk parameter block  
e926			; for the current drive.  
e926			;  
e926 2a bb e9		GETPARM:LD      HL,(DISKPB)  
e929 22 45 df		GETPRM1:LD      (STATUS),HL  
e92c c9			        RET       
e92d			;  
e92d			;   Function to get or set the user number. If (E) was (FF)  
e92d			; then this is a request to return the current user number.  
e92d			; Else set the user number from (E).  
e92d			;  
e92d 3a d6 e9		GETUSER:LD      A,(EPARAM)      ;get parameter.  
e930 fe ff		        CP      0FFH            ;get user number?  
e932 c2 3b e9		        JP      NZ,SETUSER  
e935 3a 41 df		        LD      A,(USERNO)      ;yes, just do it.  
e938 c3 01 df		        JP      SETSTAT  
e93b e6 1f		SETUSER:AND     1FH             ;no, we should set it instead. keep low  
e93d 32 41 df		        LD      (USERNO),A      ;bits (0-4) only.  
e940 c9			        RET       
e941			;  
e941			;   Function to read a random record from a file.  
e941			;  
e941 cd 51 e8		RDRANDOM: CALL  AUTOSEL         ;select proper drive and read.  
e944 c3 93 e7		        JP      READRAN  
e947			;  
e947			;   Function to compute the file size for random files.  
e947			;  
e947 cd 51 e8		WTRANDOM: CALL  AUTOSEL         ;select proper drive and write.  
e94a c3 9c e7		        JP      WRITERAN  
e94d			;  
e94d			;   Function to compute the size of a random file.  
e94d			;  
e94d cd 51 e8		FILESIZE: CALL  AUTOSEL         ;select proper drive and check file length  
e950 c3 d2 e7		        JP      RANSIZE  
e953			;  
e953			;   Function #37. This allows a program to log off any drives.  
e953			; On entry, set (DE) to contain a word with bits set for those  
e953			; drives that are to be logged off. The log-in vector and the  
e953			; write protect vector will be updated. This must be a M/PM  
e953			; special function.  
e953			;  
e953 2a 43 df		LOGOFF: LD      HL,(PARAMS)     ;get drives to log off.  
e956 7d			        LD      A,L             ;for each bit that is set, we want  
e957 2f			        CPL                     ;to clear that bit in (LOGIN)  
e958 5f			        LD      E,A             ;and (WRTPRT).  
e959 7c			        LD      A,H  
e95a 2f			        CPL       
e95b 2a af e9		        LD      HL,(LOGIN)      ;reset the login vector.  
e95e a4			        AND     H  
e95f 57			        LD      D,A  
e960 7d			        LD      A,L  
e961 a3			        AND     E  
e962 5f			        LD      E,A  
e963 2a ad e9		        LD      HL,(WRTPRT)  
e966 eb			        EX      DE,HL  
e967 22 af e9		        LD      (LOGIN),HL      ;and save.  
e96a 7d			        LD      A,L             ;now do the write protect vector.  
e96b a3			        AND     E  
e96c 6f			        LD      L,A  
e96d 7c			        LD      A,H  
e96e a2			        AND     D  
e96f 67			        LD      H,A  
e970 22 ad e9		        LD      (WRTPRT),HL     ;and save. all done.  
e973 c9			        RET       
e974			;  
e974			;   Get here to return to the user.  
e974			;  
e974 3a de e9		GOBACK: LD      A,(AUTO)        ;was auto select activated?  
e977 b7			        OR      A  
e978 ca 91 e9		        JP      Z,GOBACK1  
e97b 2a 43 df		        LD      HL,(PARAMS)     ;yes, but was a change made?  
e97e 36 00		        LD      (HL),0          ;(* reset first byte of fcb *)  
e980 3a e0 e9		        LD      A,(AUTOFLAG)  
e983 b7			        OR      A  
e984 ca 91 e9		        JP      Z,GOBACK1  
e987 77			        LD      (HL),A          ;yes, reset first byte properly.  
e988 3a df e9		        LD      A,(OLDDRV)      ;and get the old drive and select it.  
e98b 32 d6 e9		        LD      (EPARAM),A  
e98e cd 45 e8		        CALL    SETDSK  
e991 2a 0f df		GOBACK1:LD      HL,(USRSTACK)   ;reset the users stack pointer.  
e994 f9			        LD      SP,HL  
e995 2a 45 df		        LD      HL,(STATUS)     ;get return status.  
e998 7d			        LD      A,L             ;force version 1.4 compatability.  
e999 44			        LD      B,H  
e99a c9			        RET                     ;and go back to user.  
e99b			;  
e99b			;   Function #40. This is a special entry to do random i/o.  
e99b			; For the case where we are writing to unused disk space, this  
e99b			; space will be zeroed out first. This must be a M/PM special  
e99b			; purpose function, because why would any normal program even  
e99b			; care about the previous contents of a sector about to be  
e99b			; written over.  
e99b			;  
e99b cd 51 e8		WTSPECL:CALL    AUTOSEL         ;select proper drive.  
e99e 3e 02		        LD      A,2             ;use special write mode.  
e9a0 32 d5 e9		        LD      (MODE),A  
e9a3 0e 00		        LD      C,0             ;set write indicator.  
e9a5 cd 07 e7		        CALL    POSITN1         ;position the file.  
e9a8 cc 03 e6		        CALL    Z,WTSEQ1        ;and write (if no errors).  
e9ab c9			        RET       
e9ac			;  
e9ac			;**************************************************************  
e9ac			;*  
e9ac			;*     BDOS data storage pool.  
e9ac			;*  
e9ac			;**************************************************************  
e9ac			;  
e9ac e5			EMPTYFCB: DEFB  0E5H            ;empty directory segment indicator.  
e9ad 00 00		WRTPRT: DEFW    0               ;write protect status for all 16 drives.  
e9af 00 00		LOGIN:  DEFW    0               ;drive active word (1 bit per drive).  
e9b1 80 00		USERDMA:DEFW    080H            ;user's dma address (defaults to 80h).  
e9b3			;  
e9b3			;   Scratch areas from parameter block.  
e9b3			;  
e9b3 00 00		SCRATCH1: DEFW  0               ;relative position within dir segment for file (0-3).  
e9b5 00 00		SCRATCH2: DEFW  0               ;last selected track number.  
e9b7 00 00		SCRATCH3: DEFW  0               ;last selected sector number.  
e9b9			;  
e9b9			;   Disk storage areas from parameter block.  
e9b9			;  
e9b9 00 00		DIRBUF: DEFW    0               ;address of directory buffer to use.  
e9bb 00 00		DISKPB: DEFW    0               ;contains address of disk parameter block.  
e9bd 00 00		CHKVECT:DEFW    0               ;address of check vector.  
e9bf 00 00		ALOCVECT: DEFW  0               ;address of allocation vector (bit map).  
e9c1			;  
e9c1			;   Parameter block returned from the bios.  
e9c1			;  
e9c1 00 00		SECTORS:DEFW    0               ;sectors per track from bios.  
e9c3 00			BLKSHFT:DEFB    0               ;block shift.  
e9c4 00			BLKMASK:DEFB    0               ;block mask.  
e9c5 00			EXTMASK:DEFB    0               ;extent mask.  
e9c6 00 00		DSKSIZE:DEFW    0               ;disk size from bios (number of blocks-1).  
e9c8 00 00		DIRSIZE:DEFW    0               ;directory size.  
e9ca 00 00		ALLOC0: DEFW    0               ;storage for first bytes of bit map (dir space used).  
e9cc 00 00		ALLOC1: DEFW    0  
e9ce 00 00		OFFSET: DEFW    0               ;first usable track number.  
e9d0 00 00		XLATE:  DEFW    0               ;sector translation table address.  
e9d2			;  
e9d2			;  
e9d2 00			CLOSEFLG: DEFB  0               ;close flag (=0ffh is extent written ok).  
e9d3 00			RDWRTFLG: DEFB  0               ;read/write flag (0ffh=read, 0=write).  
e9d4 00			FNDSTAT:DEFB    0               ;filename found status (0=found first entry).  
e9d5 00			MODE:   DEFB    0               ;I/o mode select (0=random, 1=sequential, 2=special random).  
e9d6 00			EPARAM: DEFB    0               ;storage for register (E) on entry to bdos.  
e9d7 00			RELBLOCK: DEFB  0               ;relative position within fcb of block number written.  
e9d8 00			COUNTER:DEFB    0               ;byte counter for directory name searches.  
e9d9 00 00 00 00	SAVEFCB:DEFW    0,0             ;save space for address of fcb (for directory searches).  
e9dd 00			BIGDISK:DEFB    0               ;if =0 then disk is > 256 blocks long.  
e9de 00			AUTO:   DEFB    0               ;if non-zero, then auto select activated.  
e9df 00			OLDDRV: DEFB    0               ;on auto select, storage for previous drive.  
e9e0 00			AUTOFLAG: DEFB  0               ;if non-zero, then auto select changed drives.  
e9e1 00			SAVNXT: DEFB    0               ;storage for next record number to access.  
e9e2 00			SAVEXT: DEFB    0               ;storage for extent number of file.  
e9e3 00 00		SAVNREC:DEFW    0               ;storage for number of records in file.  
e9e5 00 00		BLKNMBR:DEFW    0               ;block number (physical sector) used within a file or logical sect  
e9e7 00 00		LOGSECT:DEFW    0               ;starting logical (128 byte) sector of block (physical sector).  
e9e9 00			FCBPOS: DEFB    0               ;relative position within buffer for fcb of file of interest.  
e9ea 00 00		FILEPOS:DEFW    0               ;files position within directory (0 to max entries -1).  
e9ec			;  
e9ec			;   Disk directory buffer checksum bytes. One for each of the  
e9ec			; 16 possible drives.  
e9ec			;  
e9ec 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00	CKSUMTBL: DEFB  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0  
e9fc			;  
e9fc			;   Extra space ?  
e9fc			;  
e9fc 00 00 00 00	        DEFB    0,0,0,0  
ea00			;  
ea00			;**************************************************************  
ea00			;*  
ea00			;*        B I O S   J U M P   T A B L E  
ea00			;*  
ea00			;**************************************************************  
ea00			;  
ea00			;BOOT:   JP      0               ;NOTE WE USE FAKE DESTINATIONS  
ea00			;WBOOT:  JP      0  
ea00			;CONST:  JP      0  
ea00			;CONIN:  JP      0  
ea00			;CONOUT: JP      0  
ea00			;LIST:   JP      0  
ea00			;PUNCH:  JP      0  
ea00			;READER: JP      0  
ea00			;HOME:   JP      0  
ea00			;SELDSK: JP      0  
ea00			;SETTRK: JP      0  
ea00			;SETSEC: JP      0  
ea00			;SETDMA: JP      0  
ea00			;READ:   JP      0  
ea00			;WRITE:  JP      0  
ea00			;PRSTAT: JP      0  
ea00			;SECTRN: JP      0  
ea00			;  
ea00			;*  
ea00			;******************   E N D   O F   C P / M   *****************  
ea00			;*  
ea00			  
# End of file cpm22.asm
ea00			 
ea00			;########################################################################## 
ea00			; 
ea00			; The BIOS vector table has to have its entries named AND located precisely 
ea00			; to match the included CP/M code above.   
ea00			; 
ea00			; Specifically, the BIOS branch vectors must start at CPM_BASE+0x1600.   
ea00			; 
ea00			;########################################################################## 
ea00			if $ != CPM_BASE+0x1600 
ea00				ERROR	THE BIOS VECTOR TABLE IS IN THE WRONG PLACE 
ea00			endif 
ea00			 
ea00 c3 33 ea		BOOT:   JP      .bios_boot 
ea03 c3 18 eb		WBOOT:  JP      .bios_wboot 
ea06 c3 d4 eb		CONST:  JP      .bios_const 
ea09 c3 d7 eb		CONIN:  JP      .bios_conin 
ea0c c3 df eb		CONOUT: JP      .bios_conout 
ea0f c3 e3 eb		LIST:   JP      .bios_list 
ea12 c3 e6 eb		PUNCH:  JP      .bios_punch 
ea15 c3 e7 eb		READER: JP      .bios_reader 
ea18 c3 ea eb		HOME:   JP      .bios_home 
ea1b c3 f2 eb		SELDSK: JP      .bios_seldsk 
ea1e c3 ed eb		SETTRK: JP      .bios_settrk 
ea21 c3 ff eb		SETSEC: JP      .bios_setsec 
ea24 c3 04 ec		SETDMA: JP      .bios_setdma 
ea27 c3 09 ec		READ:   JP      bios_read 
ea2a c3 82 ec		WRITE:  JP      bios_write 
ea2d c3 e5 eb		PRSTAT: JP      .bios_prstat 
ea30 c3 73 ef		SECTRN: JP      .bios_sectrn 
ea33			 
ea33			;########################################################################## 
ea33			; 
ea33			; CP/M 2.2 Alteration Guide p17: 
ea33			; The BOOT entry point gets control from the cold start loader and is 
ea33			; responsible for basic system initialization, including sending a signon 
ea33			; message. 
ea33			; 
ea33			; If the IOBYTE function is implemented, it must be set at this point. 
ea33			; 
ea33			; The various system parameters which are set by the WBOOT entry point 
ea33			; must be initialized (see .go_cpm), and control is transferred to the CCP  
ea33			; at 3400H+b for further processing. 
ea33			; 
ea33			; Note that reg C must be set to zero to select drive A. 
ea33			; 
ea33			;########################################################################## 
ea33			 
ea33			.bios_boot: 
ea33			 
ea33				; make sure we have a viable stack 
ea33 31 82 f2			ld	sp,bios_stack		; use the private BIOS stack to get started 
ea36			 
ea36 cd 76 ef			call	.init_console		; Note: console should still be initialized from the boot loader 
ea39 cd e4 eb			call	.init_list		; initialize the printer interface 
ea3c			 
ea3c			if .debug > 0 
ea3c				call	iputs 
ea3c				db	"\r\n.bios_boot entered\r\n\0" 
ea3c				call	iputs 
ea3c				db	"NOTICE: Debug level is set to: 0x\0" 
ea3c				ld	a,.debug		; A = the current debug level 
ea3c				call	hexdump_a		; print the current level number 
ea3c				call	puts_crlf		; and a newline 
ea3c			endif 
ea3c			 
ea3c				; Display a hello world message. 
ea3c 21 55 ea			ld	hl,.boot_msg 
ea3f cd 82 ef			call	puts 
ea42			 
ea42				; For sanity sake, wipe the zero-page so we aren't confused by  
ea42				; whatever random noise the flash boot-loader has left there. 
ea42 21 00 00			ld	hl,0 
ea45 11 01 00			ld	de,1 
ea48 01 ff 00			ld	bc,0xff 
ea4b 36 00			ld	(hl),0 
ea4d ed b0			ldir 
ea4f			 
ea4f				; Either ensure the stack is in high RAM or disable IRQs to call rw_init! 
ea4f cd 6b ef			call	rw_init			; initialize anything needed for disk read/write  
ea52			 
ea52 c3 b5 eb			jp	.go_cpm 
ea55			 
ea55			.boot_msg: 
ea55 ..				defb	'\r\n\n' 
ea58 ..				defb	'Z80 Retro BIOS Copyright (C) 2021 John Winans\r\n' 
ea87 ..				defb	'CP/M 2.2 Copyright (C) 1979 Digital Research\r\n' 
eab5 ..				defb	'  git: v20221003.2-6-gf83f1b7-dirty 2022-11-24 12:54:14 -0600\r\n' 
eaf4 ..				defb	'build: 2023-01-04 18:08:31-05:00\r\n' 
eb16 ..				defb	'\n' 
eb17 ..				defb	'\0' 
eb18			 
eb18			;########################################################################## 
eb18			; 
eb18			; CP/M 2.2 Alteration Guide p17: 
eb18			; The WBOOT entry point gets control when a warm start occurs.  A warm 
eb18			; start is performed whenever a user program branches to location 0x0000. 
eb18			; 
eb18			; The CP/M CCP and BDOS must be re-loaded from the first two tracks of  
eb18			; drive A up to, but not including, the BIOS. 
eb18			; 
eb18			; The WBOOT & BDOS jump instructions in page-zero must be initialized  
eb18			; (see .go_cpm), and control is transferred to the CCP at 3400H+b for  
eb18			; further processing. 
eb18			; 
eb18			; Upon completion of the initialization, the WBOOT program must branch 
eb18			; to the CCP at 3400H+b to (re)start the system. Upon entry to the CCP, 
eb18			; register C is set to the drive to select after system initialization. 
eb18			; 
eb18			;########################################################################## 
eb18			 
eb18			; WARNING: The following assumes that CPM_BASE%128 is zero! 
eb18			 
eb18			.wb_nsects:	equ (BOOT-CPM_BASE)/128			; number of sectors to load 
eb18			.wb_trk:	equ (CPM_BASE-LOAD_BASE)/512		; first track number (rounded down) 
eb18			.wb_sec:	equ ((CPM_BASE-LOAD_BASE)/128)&0x03	; first sector number 
eb18			 
eb18			.bios_wboot: 
eb18				; We can't just blindly set SP=bios_stack here because bios_read will overwrite it! 
eb18				; But we CAN set to use other areas that we KNOW are not currently in use! 
eb18 31 34 f0			ld	sp,.bios_wboot_stack			; the .bios_dirbuf is garbage right now 
eb1b			 
eb1b			if .debug >= 2 
eb1b				call	iputs 
eb1b				db	"\r\n.bios_wboot entered\r\n\0" 
eb1b			endif 
eb1b			 
eb1b				; ask host to clear the display 
eb1b			;	ld	a,host_cls_cmd 
eb1b			;	out	(host_concmd_port),a 
eb1b			 
eb1b				; XXX Should not need to reinitialize the cache for a warm boot 
eb1b				; Either ensure the stack is in high RAM or disable IRQs to call rw_init! 
eb1b				;call	rw_init			; initialize anything needed for disk read/write  
eb1b			 
eb1b				; reload the CCP and BDOS 
eb1b			 
eb1b 0e 00			ld	c,0			; C = drive number (0=A) 
eb1d cd f2 eb			call	.bios_seldsk		; load the OS from drive A 
eb20			 
eb20 01 0a 00			ld	bc,.wb_trk		; BC = track number whgere the CCP starts 
eb23 cd ed eb			call	.bios_settrk 
eb26			 
eb26 01 00 00			ld	bc,.wb_sec		; sector where the CCP begins on .wb_trk 
eb29 cd ff eb			call	.bios_setsec 
eb2c			 
eb2c 01 00 d4			ld	bc,CPM_BASE		; starting address to read the OS into 
eb2f cd 04 ec			call	.bios_setdma 
eb32			 
eb32 01 2c 00			ld	bc,.wb_nsects		; BC = gross number of sectors to read 
eb35			.wboot_loop: 
eb35 c5				push	bc			; save the remaining sector count 
eb36			 
eb36 cd 09 ec			call	bios_read		; read 1 sector 
eb39			 
eb39 b7				or	a			; bios_read sets A=0 on success 
eb3a 28 50			jr	z,.wboot_sec_ok		; if read was OK, continue processing 
eb3c			 
eb3c				; If there was a read error, stop. 
eb3c cd 7b ef			call	iputs 
eb3f ..				db      "\r\n\r\nERROR: WBOOT READ FAILED.  HALTING." 
eb66 ..				db      "\r\n\n*** PRESS RESET TO REBOOT ***\r\n" 
eb88 00				db      0 
eb89 c3 89 eb			jp      $               ; endless spin loop 
eb8c			 
eb8c			.wboot_sec_ok: 
eb8c				; advance the DMA pointer by 128 bytes 
eb8c 2a 9d ef			ld	hl,(bios_disk_dma)	; HL = the last used DMA address 
eb8f 11 80 00			ld	de,128 
eb92 19				add	hl,de			; HL += 128 
eb93 44				ld	b,h 
eb94 4d				ld	c,l			; BC = HL 
eb95 cd 04 ec			call	.bios_setdma 
eb98			 
eb98				; increment the sector/track numbers 
eb98 3a a2 ef			ld	a,(bios_disk_sector)	; A = last used sector number (low byte only for 0..3) 
eb9b 3c				inc	a 
eb9c e6 03			and	0x03			; if A+1 = 4 then A=0 
eb9e 20 09			jr	nz,.wboot_sec		; if A+1 !=4 then do not advance the track number 
eba0			 
eba0				; advance to the next track 
eba0 ed 4b 9f ef		ld	bc,(bios_disk_track) 
eba4 03				inc	bc 
eba5 cd ed eb			call	.bios_settrk 
eba8 af				xor	a			; set A=0 for first sector on new track 
eba9			 
eba9			.wboot_sec: 
eba9 06 00			ld	b,0 
ebab 4f				ld	c,a 
ebac cd ff eb			call	.bios_setsec 
ebaf			 
ebaf c1				pop	bc			; BC = remaining sector counter value 
ebb0 0b				dec	bc			; BC -= 1 
ebb1 78				ld	a,b 
ebb2 b1				or	c 
ebb3 20 80			jr	nz,.wboot_loop		; if BC != 0 then goto .wboot_loop 
ebb5			 
ebb5				; fall through into .go_cpm... 
ebb5			 
ebb5			.go_cpm: 
ebb5 3e c3			ld	a,0xc3		; opcode for JP 
ebb7 32 00 00			ld	(0),a 
ebba 21 03 ea			ld	hl,WBOOT 
ebbd 22 01 00			ld	(1),hl		; address 0 now = JP WBOOT 
ebc0			 
ebc0 32 05 00			ld	(5),a		; opcode for JP 
ebc3 21 06 dc			ld	hl,FBASE 
ebc6 22 06 00			ld	(6),hl		; address 6 now = JP FBASE 
ebc9			 
ebc9 01 80 00			ld	bc,0x80		; this is here because it is in the example CBIOS (AG p.52) 
ebcc cd 04 ec			call	.bios_setdma 
ebcf			 
ebcf			if .debug >= 3 
ebcf				; dump the zero-page for reference 
ebcf				ld	hl,0		; start address 
ebcf				ld	bc,0x100	; number of bytes 
ebcf				ld	e,1		; fancy format 
ebcf				call	hexdump 
ebcf			endif 
ebcf			 
ebcf			if 0 
ebcf				; This is not quite right because it include the user number and 
ebcf				; can get us stuck re-selesting an invalid disk drive! 
ebcf				ld	a,(4)		; load the current disk # from page-zero into a/c 
ebcf				and	0x0f		; the drive number is in the 4 lsbs 
ebcf				ld	c,a 
ebcf			else 
ebcf 0e 00			ld	c,0		; The ONLY valid drive WE have is A! 
ebd1			endif 
ebd1 c3 00 d4			jp	CPM_BASE	; start the CCP 
ebd4			 
ebd4			;########################################################################## 
ebd4			; 
ebd4			; CP/M 2.2 Alteration Guide p17: 
ebd4			; If the console device is ready for reading then return 0FFH in register A. 
ebd4			; Else return 00H in register A. 
ebd4			; 
ebd4			;########################################################################## 
ebd4			.bios_const: 
ebd4 db ff			in	a,(host_const_port) 
ebd6 c9				ret			; A = 0xff = ready 
ebd7			 
ebd7			;########################################################################## 
ebd7			; 
ebd7			; CP/M 2.2 Alteration Guide p17: 
ebd7			; Read the next console character into register A and set the parity bit 
ebd7			; (high order bit) to zero.  If no console character is ready, wait until 
ebd7			; a character is typed before returning. 
ebd7			; 
ebd7			;########################################################################## 
ebd7			.bios_conin: 
ebd7 db ff			in	a,(host_const_port) 
ebd9 b7				or	a 
ebda 28 fb			jr	z,.bios_conin 
ebdc db fe			in	a,(host_conin_port) 
ebde c9				ret 
ebdf			 
ebdf			;########################################################################## 
ebdf			; 
ebdf			; CP/M 2.2 Alteration Guide p18: 
ebdf			; Send the character from register C to the console output device.  The 
ebdf			; character is in ASCII, with high order parity bit set to zero. 
ebdf			; 
ebdf			;########################################################################## 
ebdf			.bios_conout: 
ebdf 79				ld	a,c 
ebe0 d3 fe			out	(host_conout_port),a 
ebe2 c9				ret 
ebe3			 
ebe3			;########################################################################## 
ebe3			; 
ebe3			; CP/M 2.2 Alteration Guide p18: 
ebe3			; Send the character from register C to the currently assigned listing 
ebe3			; device.  The character is in ASCII with zero parity. 
ebe3			; 
ebe3			;########################################################################## 
ebe3			.bios_list: 
ebe3 c9				ret 
ebe4			 
ebe4			.init_list: 
ebe4 c9				ret 
ebe5			 
ebe5			;########################################################################## 
ebe5			; 
ebe5			; CP/M 2.2 Alteration Guide p20: 
ebe5			; Return the ready status of the list device.  Used by the DESPOOL program 
ebe5			; to improve console response during its operation.  The value 00 is 
ebe5			; returned in A of the list device is not ready to accept a character, and 
ebe5			; 0FFH if a character can be sent to the printer.  
ebe5			; 
ebe5			; Note that a 00 value always suffices. 
ebe5			; 
ebe5			; Clobbers AF 
ebe5			;########################################################################## 
ebe5			.bios_prstat: 
ebe5 c9				ret 
ebe6			 
ebe6			;########################################################################## 
ebe6			; 
ebe6			; CP/M 2.2 Alteration Guide p18: 
ebe6			; Send the character from register C to the currently assigned punch device. 
ebe6			; The character is in ASCII with zero parity. 
ebe6			; 
ebe6			; The Z80 Retro! has no punch device. Discard any data written. 
ebe6			; 
ebe6			;########################################################################## 
ebe6			.bios_punch: 
ebe6 c9				ret 
ebe7			 
ebe7			;########################################################################## 
ebe7			; 
ebe7			; CP/M 2.2 Alteration Guide p18: 
ebe7			; Read the next character from the currently assigned reader device into 
ebe7			; register A with zero parity (high order bit must be zero), an end of 
ebe7			; file condition is reported by returning an ASCII control-Z (1AH). 
ebe7			; 
ebe7			; The Z80 Retro! has no tape device. Return the EOF character. 
ebe7			; 
ebe7			;########################################################################## 
ebe7			.bios_reader: 
ebe7 3e 1a			ld	a,0x1a 
ebe9 c9				ret 
ebea			 
ebea			;########################################################################## 
ebea			; 
ebea			; CP/M 2.2 Alteration Guide p18: 
ebea			; Return the disk head of the currently selected disk to the track  
ebea			; 00 position. 
ebea			; 
ebea			; The Z80 Retro! does not have a mechanical disk drive. So just treat 
ebea			; this like a SETTRK 0. 
ebea			; 
ebea			;########################################################################## 
ebea			.bios_home: 
ebea			if .debug >= 2 
ebea				call	iputs 
ebea				db	".bios_home entered\r\n\0" 
ebea			endif 
ebea			 
ebea 01 00 00			ld	bc,0		; BC = 0 = track number passed into .bios_settrk 
ebed			 
ebed				; Fall into .bios_settrk <--------------- NOTICE!! 
ebed			 
ebed			;########################################################################## 
ebed			; 
ebed			; CP/M 2.2 Alteration Guide p19: 
ebed			; Register BC contains the track number for subsequent disk 
ebed			; accesses on the currently selected drive.  BC can take on 
ebed			; values from 0-65535. 
ebed			; 
ebed			;########################################################################## 
ebed			.bios_settrk: 
ebed ed 43 9f ef		ld	(bios_disk_track),bc 
ebf1			 
ebf1			if .debug >= 2 
ebf1				call	iputs 
ebf1				db	".bios_settrk entered: \0" 
ebf1				call	bios_debug_disk 
ebf1			endif 
ebf1 c9				ret 
ebf2			 
ebf2			;########################################################################## 
ebf2			; 
ebf2			; CP/M 2.2 Alteration Guide p18: 
ebf2			; Select the disk drive given by register C for further operations, where 
ebf2			; register C contains 0 for drive A, 1 for drive B, and so-forth UP to 15 
ebf2			; for drive P. 
ebf2			; 
ebf2			; On each disk select, SELDSK must return in HL the base address of a  
ebf2			; l6-byte area, called the Disk Parameter Header for the selected drive. 
ebf2			; 
ebf2			; If there is an attempt to select a non-existent drive, SELDSK returns 
ebf2			; HL=0000H as an error indicator. 
ebf2			; 
ebf2			; The Z80 Retro! only has one drive. 
ebf2			; 
ebf2			;########################################################################## 
ebf2			.bios_seldsk: 
ebf2 79				ld	a,c 
ebf3 32 a1 ef			ld	(bios_disk_disk),a	; XXX should we save this now or defer  
ebf6								; till after we validate the value? 
ebf6 d3 f4			out	(host_sel_dsk_port),a 
ebf8 cd 6b ef			call	rw_init 
ebfb			 
ebfb			if .debug >= 2 
ebfb				call	iputs 
ebfb				db	".bios_seldsk entered: \0" 
ebfb				call	bios_debug_disk 
ebfb			endif 
ebfb			 
ebfb			;	ld	hl,0			; HL = 0 = invalid disk  
ebfb			;	ld	a,(bios_disk_disk) 
ebfb			;	or	a			; did drive A get selected? 
ebfb			;	ret	nz			; no -> error 
ebfb			 
ebfb 21 a4 ef			ld	hl,.bios_dph		; the DPH for disk A 
ebfe c9				ret 
ebff			 
ebff			;########################################################################## 
ebff			; 
ebff			; CP/M 2.2 Alteration Guide p19: 
ebff			; Register BC contains the sector number for subsequent disk accesses on 
ebff			; the currently selected drive. 
ebff			; 
ebff			;########################################################################## 
ebff			.bios_setsec: 
ebff ed 43 a2 ef		ld	(bios_disk_sector),bc 
ec03			 
ec03			if .debug >= 2 
ec03				call	iputs 
ec03				db	".bios_setsec entered: \0" 
ec03				call	bios_debug_disk 
ec03			endif 
ec03			 
ec03 c9				ret 
ec04			 
ec04			;########################################################################## 
ec04			; 
ec04			; CP/M 2.2 Alteration Guide p19: 
ec04			; Register BC contains the DMA (disk memory access) address for subsequent 
ec04			; read or write operations.  For example, if B = 00H and C = 80H when SETDMA 
ec04			; is called, then all subsequent read operations read their data into 80H 
ec04			; through 0FFH, and all subsequent write operations get their data from 
ec04			; 80H through 0FFH, until the next call to SETDMA changes it. 
ec04			; 
ec04			;########################################################################## 
ec04			.bios_setdma: 
ec04 ed 43 9d ef		ld	(bios_disk_dma),bc 
ec08			 
ec08			if .debug >= 2 
ec08				call	iputs 
ec08				db	".bios_setdma entered: \0" 
ec08				call	bios_debug_disk 
ec08			endif 
ec08			 
ec08 c9				ret 
ec09			 
ec09			;########################################################################## 
ec09			; A debug routing for displaying the settings before a read or write 
ec09			; operation. 
ec09			; 
ec09			; Clobbers AF, C 
ec09			;########################################################################## 
ec09			if .debug >= 1 
ec09			bios_debug_disk: 
ec09				call	iputs 
ec09				db	'disk=0x\0' 
ec09			 
ec09				ld	a,(bios_disk_disk) 
ec09				call	hexdump_a 
ec09			 
ec09				call    iputs 
ec09				db	", track=0x\0" 
ec09				ld	a,(bios_disk_track+1) 
ec09				call	hexdump_a 
ec09				ld	a,(bios_disk_track) 
ec09				call	hexdump_a 
ec09			 
ec09				call	iputs 
ec09				db	", sector=0x\0" 
ec09				ld	a,(bios_disk_sector+1) 
ec09				call	hexdump_a 
ec09				ld	a,(bios_disk_sector) 
ec09				call	hexdump_a 
ec09			 
ec09				call	iputs 
ec09				db	", dma=0x\0" 
ec09				ld	a,(bios_disk_dma+1) 
ec09				call	hexdump_a 
ec09				ld	a,(bios_disk_dma) 
ec09				call	hexdump_a 
ec09				call	puts_crlf 
ec09			 
ec09				ret 
ec09			endif 
ec09			 
ec09			; Pick the preferred flavor of SD read/write routines. 
ec09			 
ec09			include 'rw_nocache.asm' 
ec09			;**************************************************************************** 
ec09			; 
ec09			;    Z80 Retro! BIOS  
ec09			; 
ec09			;    Copyright (C) 2021,2022 John Winans 
ec09			; 
ec09			;    This library is free software; you can redistribute it and/or 
ec09			;    modify it under the terms of the GNU Lesser General Public 
ec09			;    License as published by the Free Software Foundation; either 
ec09			;    version 2.1 of the License, or (at your option) any later version. 
ec09			; 
ec09			;    This library is distributed in the hope that it will be useful, 
ec09			;    but WITHOUT ANY WARRANTY; without even the implied warranty of 
ec09			;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
ec09			;    Lesser General Public License for more details. 
ec09			; 
ec09			;    You should have received a copy of the GNU Lesser General Public 
ec09			;    License along with this library; if not, write to the Free Software 
ec09			;    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 
ec09			;    USA 
ec09			; 
ec09			;**************************************************************************** 
ec09			 
ec09			;########################################################################## 
ec09			; set .rw_debug to: 
ec09			;    0 = no debug output 
ec09			;    1 = print messages from new code under development 
ec09			;    2 = print all the above plus the primairy 'normal' debug messages 
ec09			;    3 = print all the above plus verbose 'noisy' debug messages 
ec09			;########################################################################## 
ec09			.rw_debug:	equ	0 
ec09			 
ec09			; XXX This is a hack that won't work unless the disk partition < 0x10000 
ec09			; XXX This has the SD card partition offset hardcoded in it!!! 
ec09			.sd_partition_base:   equ 0x800 
ec09			 
ec09			;########################################################################## 
ec09			; 
ec09			; CP/M 2.2 Alteration Guide p19: 
ec09			; Assuming the drive has been selected, the track has been set, the sector 
ec09			; has been set, and the DMA address has been specified, the READ subroutine 
ec09			; attempts to read one sector based upon these parameters, and returns the 
ec09			; following error codes in register A: 
ec09			; 
ec09			;    0 no errors occurred 
ec09			;    1 non-recoverable error condition occurred 
ec09			; 
ec09			; When an error is reported the BDOS will print the message "BDOS ERR ON 
ec09			; x: BAD SECTOR".  The operator then has the option of typing <cr> to ignore 
ec09			; the error, or ctl-C to abort. 
ec09			; 
ec09			;########################################################################## 
ec09			bios_read: 
ec09			if .rw_debug >= 1 
ec09				call	iputs 
ec09				db	".bios_read entered: \0" 
ec09				call	bios_debug_disk 
ec09			endif 
ec09				; switch to a local stack (we only have a few levels when called from the BDOS!) 
ec09 e5				push	hl			; save HL into the caller's stack 
ec0a 21 00 00			ld	hl,0 
ec0d 39				add	hl,sp			; HL = SP 
ec0e 31 82 f2			ld	sp,bios_stack		; SP = temporary private BIOS stack area 
ec11 e5				push	hl			; save the old SP value in the BIOS stack 
ec12			 
ec12 c5				push	bc			; save the register pairs we will otherwise clobber 
ec13 d5				push	de			; this is not critical but may make WBOOT cleaner later 
ec14			 
ec14 2a 9f ef			ld	hl,(bios_disk_track)	; HL = CP/M track number 
ec17			 
ec17				; Check to see if the SD block in .bios_sdbuf is already the one we want 
ec17 3a 6a ed			ld	a,(.bios_sdbuf_val)	; get the .bios_sdbuf valid flag 
ec1a b7				or	a			; is it a non-zero value? 
ec1b 20 0c			jr	nz,.bios_read_block	; block buffer is invalid, read the SD block 
ec1d			 
ec1d 3a 68 ed			ld	a,(.bios_sdbuf_trk)	; A = CP/M track LSB 
ec20 bd				cp	l			; is it the one we want? 
ec21 20 06			jr	nz,.bios_read_block	; LSB does not match, read the SD block 
ec23			 
ec23 3a 69 ed			ld	a,(.bios_sdbuf_trk+1)	; A = CP/M track MSB 
ec26 bc				cp	h			; is it the one we want? 
ec27 28 3b			jr	z,.bios_read_sd_ok	; The SD block in .bios_sdbuf is the one we want! 
ec29			 
ec29			.bios_read_block: 
ec29			if .rw_debug >= 2 
ec29				call	iputs 
ec29				db	".bios_read cache miss: \0" 
ec29				call	bios_debug_disk 
ec29			endif 
ec29			 
ec29				; Assume all will go well reading the SD card block. 
ec29				; We only need to touch this if we are going to actually read the SD card. 
ec29 22 68 ed			ld	(.bios_sdbuf_trk),hl	; store the current CP/M track number in the .bios_sdbuf 
ec2c af				xor	a			; A = 0 
ec2d 32 6a ed			ld	(.bios_sdbuf_val),a	; mark the .bios_sdbuf as valid 
ec30			 
ec30 11 00 08			ld	de,.sd_partition_base	; XXX add the starting partition block number 
ec33 19				add	hl,de			; HL = SD physical block number 
ec34			 
ec34				; push the 32-bit physical SD block number into the stack in little-endian order 
ec34 11 00 00			ld	de,0 
ec37 d5				push	de			; 32-bit SD block number (big end) 
ec38 e5				push	hl			; 32-bit SD block number (little end) 
ec39 11 6b ed			ld	de,.bios_sdbuf		; DE = target buffer to read the 512-byte block 
ec3c			 
ec3c				; send request to host to read disk image block 
ec3c				;  HL - block number to read 
ec3c				;  DE - address to put data read 
ec3c				;     - block size assumed to be 512-bytes 
ec3c 3e 10			ld	a,host_read_block_cmd 
ec3e d3 f5			out	(host_sd_cmd_port),a 
ec40			 
ec40 e1				pop	hl			; clean the SD block number from the stack 
ec41 d1				pop	de 
ec42			 
ec42 b7				or	a			; was the SD driver read OK? 
ec43 28 1f			jr	z,.bios_read_sd_ok 
ec45			 
ec45 cd 7b ef			call	iputs 
ec48 ..				db	"BIOS_READ FAILED!\r\n\0" 
ec5c 3e 01			ld	a,1			; tell CP/M the read failed 
ec5e 32 6a ed			ld	(.bios_sdbuf_val),a	; mark the .bios_sdbuf as invalid 
ec61 c3 7c ec			jp	.bios_read_ret 
ec64			 
ec64			.bios_read_sd_ok: 
ec64			 
ec64				; calculate the CP/M sector offset address (bios_disk_sector*128) 
ec64 2a a2 ef			ld	hl,(bios_disk_sector)	; must be 0..3 
ec67 29				add	hl,hl			; HL *= 2 
ec68 29				add	hl,hl			; HL *= 4 
ec69 29				add	hl,hl			; HL *= 8 
ec6a 29				add	hl,hl			; HL *= 16 
ec6b 29				add	hl,hl			; HL *= 32 
ec6c 29				add	hl,hl			; HL *= 64 
ec6d 29				add	hl,hl			; HL *= 128 
ec6e			 
ec6e				; calculate the address of the CP/M sector in the .bios_sdbuf 
ec6e 01 6b ed			ld	bc,.bios_sdbuf 
ec71 09				add	hl,bc			; HL = @ of cpm sector in the .bios_sdbuf 
ec72			 
ec72				; copy the data of interest from the SD block 
ec72 ed 5b 9d ef		ld	de,(bios_disk_dma)		; target address 
ec76 01 80 00			ld	bc,0x0080		; number of bytes to copy 
ec79 ed b0			ldir 
ec7b			 
ec7b af				xor	a			; A = 0 = read OK 
ec7c			 
ec7c			.bios_read_ret: 
ec7c d1				pop	de			; restore saved regs 
ec7d c1				pop	bc 
ec7e			 
ec7e e1				pop	hl			; HL = original saved stack pointer 
ec7f f9				ld	sp,hl			; SP = original stack address 
ec80 e1				pop	hl			; restore the original  HL value 
ec81			 
ec81 c9				ret 
ec82			 
ec82			;########################################################################## 
ec82			; 
ec82			; CP/M 2.2 Alteration Guide p19: 
ec82			; Write the data from the currently selected DMA address to the currently 
ec82			; selected drive, track, and sector.  The error codes given in the READ 
ec82			; command are returned in register A: 
ec82			; 
ec82			;    0 no errors occurred 
ec82			;    1 non-recoverable error condition occurred 
ec82			; 
ec82			; p34 adds: Upon entry the value of C will be useful for blocking 
ec82			; and deblocking a drive's physical sector sizes: 
ec82			; 
ec82			;  0 = normal sector write 
ec82			;  1 = write into a directory sector 
ec82			;  2 = first sector of a newly used block 
ec82			; 
ec82			; Return the following completion status in register A: 
ec82			; 
ec82			;    0 no errors occurred 
ec82			;    1 non-recoverable error condition occurred 
ec82			; 
ec82			; When an error is reported the BDOS will print the message "BDOS ERR ON 
ec82			; x: BAD SECTOR".  The operator then has the option of typing <cr> to ignore 
ec82			; the error, or ctl-C to abort. 
ec82			; 
ec82			;########################################################################## 
ec82			bios_write: 
ec82			 
ec82			if .rw_debug >= 1 
ec82				push	bc 
ec82				call	iputs 
ec82				db	".bios_write entered, C=\0" 
ec82				pop	bc 
ec82				push	bc 
ec82				ld	a,c 
ec82				call	hexdump_a 
ec82				call	iputs 
ec82				db	": \0" 
ec82				call	bios_debug_disk 
ec82				pop	bc 
ec82			endif 
ec82			 
ec82				; switch to a local stack (we only have a few levels when called from the BDOS!) 
ec82 e5				push	hl			; save HL into the caller's stack 
ec83 21 00 00			ld	hl,0 
ec86 39				add	hl,sp			; HL = SP 
ec87 31 82 f2			ld	sp,bios_stack		; SP = temporary private BIOS stack area 
ec8a e5				push	hl			; save the old SP value in the BIOS stack 
ec8b			 
ec8b d5				push	de			; save the register pairs we will otherwise clobber 
ec8c c5				push	bc 
ec8d			 
ec8d 2a 9f ef			ld	hl,(bios_disk_track)	; HL = CP/M track number 
ec90			 
ec90				; Check to see if the SD block in .bios_sdbuf is already the one we want 
ec90 3a 6a ed			ld	a,(.bios_sdbuf_val)	; get the .bios_sdbuf valid flag 
ec93 b7				or	a			; is it a non-zero value? 
ec94 20 0d			jr	nz,.bios_write_miss	; block buffer is invalid, pre-read the SD block 
ec96			 
ec96 3a 68 ed			ld	a,(.bios_sdbuf_trk)	; A = CP/M track LSB 
ec99 bd				cp	l			; is it the one we want? 
ec9a 20 07			jr	nz,.bios_write_miss	; LSB does not match, pre-read the SD block 
ec9c			 
ec9c 3a 69 ed			ld	a,(.bios_sdbuf_trk+1)	; A = CP/M track MSB 
ec9f bc				cp	h			; is it the one we want? 
eca0 ca 07 ed			jp	z,.bios_write_sdbuf	; The SD block in .bios_sdbuf is the one we want! 
eca3			 
eca3			.bios_write_miss: 
eca3			if .rw_debug >= 1 
eca3				call	iputs 
eca3				db	".bios_write cache miss: \0" 
eca3				call	bios_debug_disk 
eca3			endif 
eca3			 
eca3				; Assume all will go well reading the SD card block. 
eca3				; We only need to touch this if we are going to actually read the SD card. 
eca3 22 68 ed			ld	(.bios_sdbuf_trk),hl	; store the current CP/M track number in the .bios_sdbuf 
eca6 af				xor	a			; A = 0 
eca7 32 6a ed			ld	(.bios_sdbuf_val),a	; mark the .bios_sdbuf as valid 
ecaa			 
ecaa			 
ecaa				; if C==2 then we are writing into an alloc block (and therefore an SD block) that is not dirty 
ecaa c1				pop	bc			; restore C in case was clobbered above 
ecab c5				push	bc 
ecac 3e 02			ld	a,2 
ecae b9				cp	c 
ecaf 20 10			jr	nz,.bios_write_prerd 
ecb1			 
ecb1				; padd the SD buffer with all 0xe5 
ecb1 21 6b ed			ld	hl,.bios_sdbuf		; buffer to initialize 
ecb4 11 6c ed			ld	de,.bios_sdbuf+1	; buffer+1 
ecb7 01 ff 01			ld	bc,0x1ff		; number of bytes to initialize 
ecba 36 e5			ld	(hl),0xe5		; set the first byte to 0xe5 
ecbc ed b0			ldir				; set the rest of the bytes to 0xe5 
ecbe c3 07 ed			jp	.bios_write_sdbuf	; go to write logic (skip the SD card pre-read) 
ecc1			 
ecc1			.bios_write_prerd: 
ecc1				; pre-read the block so we can replace one sector and write it back 
ecc1				; XXX This is a hack that won't work unless the disk partition < 0x10000 
ecc1				; XXX This has the SD card partition offset hardcoded in it!!! 
ecc1 11 00 08			ld	de,.sd_partition_base	; XXX add the starting partition block number 
ecc4 19				add	hl,de			; HL = SD physical block number 
ecc5			 
ecc5				; push the 32-bit physical SD block number into the stack in little-endian order 
ecc5 11 00 00			ld	de,0 
ecc8 d5				push	de			; 32-bit SD block number (big end) 
ecc9 e5				push	hl			; 32-bit SD block number (little end) 
ecca 11 6b ed			ld	de,.bios_sdbuf		; DE = target buffer to read the 512-byte block 
eccd			 
eccd				; pre-read the SD block 
eccd				; send request to host to read disk image block 
eccd				;  HL - block number to read 
eccd				;  DE - address to put data read 
eccd				;     - block size assumed to be 512-bytes 
eccd 3e 10			ld	a,host_read_block_cmd 
eccf d3 f5			out	(host_sd_cmd_port),a 
ecd1			 
ecd1 e1				pop	hl			; clean the SD block number from the stack 
ecd2 d1				pop	de 
ecd3			 
ecd3 b7				or	a			; was the SD driver read OK? 
ecd4 28 31			jr	z,.bios_write_sdbuf 
ecd6			 
ecd6 cd 7b ef			call	iputs 
ecd9 ..				db	"BIOS_WRITE SD CARD PRE-READ FAILED!\r\n\0" 
ecff 3e 01			ld	a,1			; tell CP/M the read failed 
ed01 32 6a ed			ld	(.bios_sdbuf_val),a	; mark the .bios_sdbuf as invalid 
ed04 c3 62 ed			jp	.bios_write_ret 
ed07			 
ed07			.bios_write_sdbuf: 
ed07				; calculate the CP/M sector offset address (bios_disk_sector*128) 
ed07 2a a2 ef			ld	hl,(bios_disk_sector)	; must be 0..3 
ed0a 29				add	hl,hl			; HL *= 2 
ed0b 29				add	hl,hl			; HL *= 4 
ed0c 29				add	hl,hl			; HL *= 8 
ed0d 29				add	hl,hl			; HL *= 16 
ed0e 29				add	hl,hl			; HL *= 32 
ed0f 29				add	hl,hl			; HL *= 64 
ed10 29				add	hl,hl			; HL *= 128 
ed11			 
ed11				; calculate the address of the CP/M sector in the .bios_sdbuf 
ed11 01 6b ed			ld	bc,.bios_sdbuf 
ed14 09				add	hl,bc			; HL = @ of cpm sector in the .bios_sdbuf 
ed15 54				ld	d,h 
ed16 5d				ld	e,l			; DE = @ of cpm sector in the .bios_sdbuf 
ed17			 
ed17				; copy the data of interest /into/ the SD block 
ed17 2a 9d ef			ld	hl,(bios_disk_dma)		; source address 
ed1a 01 80 00			ld	bc,0x0080		; number of bytes to copy 
ed1d ed b0			ldir 
ed1f			 
ed1f				; write the .bios_sdbuf contents to the SD card 
ed1f 2a 9f ef			ld      hl,(bios_disk_track) 
ed22 11 00 08			ld	de,.sd_partition_base	; XXX add the starting partition block number 
ed25 19				add	hl,de			; HL = SD physical block number 
ed26 11 00 00			ld	de,0 
ed29 d5				push	de			; SD block number to write 
ed2a e5				push	hl 
ed2b 11 6b ed			ld	de,.bios_sdbuf		; DE = target buffer to read the 512-byte block 
ed2e			 
ed2e				; send request to host to write disk image block 
ed2e				;  HL - block number 
ed2e				;  DE - address for data to write 
ed2e				;     - block size assumed to be 512-bytes 
ed2e 3e 11			ld	a,host_write_block_cmd 
ed30 d3 f5			out	(host_sd_cmd_port),a 
ed32			 
ed32 e1				pop	hl			; clean the SD block number from the stack 
ed33 d1				pop	de 
ed34			 
ed34 b7				or	a 
ed35 28 2b			jr	z,.bios_write_ret 
ed37			 
ed37 cd 7b ef			call	iputs 
ed3a ..				db	"BIOS_WRITE SD CARD WRITE FAILED!\r\n\0" 
ed5d 3e 01			ld	a,1			; tell CP/M the read failed 
ed5f 32 6a ed			ld	(.bios_sdbuf_val),a	; mark the .bios_sdbuf as invalid 
ed62			 
ed62			.bios_write_ret: 
ed62 c1				pop	bc 
ed63 d1				pop	de			; restore saved regs 
ed64			 
ed64 e1				pop	hl			; HL = original saved stack pointer 
ed65 f9				ld	sp,hl			; SP = original stack address 
ed66 e1				pop	hl			; restore the original  HL value 
ed67			 
ed67 c9				ret 
ed68			 
ed68			;########################################################################## 
ed68			; A single SD block cache 
ed68			;########################################################################## 
ed68			.bios_sdbuf_trk:		; The CP/M track number last left in the .bios_sdbuf 
ed68 0xff...			ds	2,0xff		; initial value = garbage 
ed6a			.bios_sdbuf_val:		; The CP/M track number in .bios_sdbuf_trk is valid when this is 0 
ed6a 0xff...			ds	1,0xff		; initial value = INVALID 
ed6b			.bios_sdbuf:			; scratch area to use for SD block reading and writing 
ed6b 0xa5...			ds	512,0xa5	; initial value = garbage 
ef6b			 
ef6b			;########################################################################## 
ef6b			; Called once before library is used. 
ef6b			;########################################################################## 
ef6b			rw_init: 
ef6b			;	call	iputs 
ef6b			;	db	'NOTICE: rw_nocache library installed. Disk cache disabled.\r\n\0' 
ef6b f5				push	af 
ef6c 3e 01			ld	a,1 
ef6e 32 6a ed			ld	(.bios_sdbuf_val),a     ; mark .bios_sdbuf_trk as invalid 
ef71 f1				pop	af 
ef72 c9			        ret 
# End of file rw_nocache.asm
ef73			 
ef73			;########################################################################## 
ef73			; 
ef73			; CP/M 2.2 Alteration Guide p20: 
ef73			; Performs sector logical to physical sector translation in order to improve 
ef73			; the overall response of CP/M. 
ef73			; 
ef73			; Xlate the sector number in BC using table in DE & return in HL 
ef73			; If DE=0 here then translation is 1:1 
ef73			; 
ef73			; The Z80 Retro! does not translate its sectors.  Therefore it will return 
ef73			; HL = BC for a 1:1 translation. 
ef73			; 
ef73			;########################################################################## 
ef73			.bios_sectrn: 
ef73				; 1:1 translation  (no skew factor) 
ef73 60				ld	h,b 
ef74 69				ld	l,c 
ef75 c9				ret 
ef76			 
ef76			;########################################################################## 
ef76			; Initialize the console port.  Note that this includes CTC port 1. 
ef76			;########################################################################## 
ef76			.init_console: 
ef76 c9				ret 
ef77			 
ef77			;########################################################################## 
ef77			con_tx_char: 
ef77 79				ld	a,c 
ef78 d3 fe			out	(host_conout_port),a	; send the character 
ef7a c9				ret 
ef7b			 
ef7b			;############################################################## 
ef7b			; Write the null-terminated string starting after the call 
ef7b			; instruction invoking this subroutine to the console. 
ef7b			; Clobbers AF, C 
ef7b			;############################################################## 
ef7b			iputs: 
ef7b e3			        ex      (sp),hl                 ; hl = @ of string to print 
ef7c cd 88 ef			call	.puts_loop 
ef7f 23			        inc     hl                      ; point past the end of the string 
ef80 e3			        ex      (sp),hl 
ef81 c9			        ret 
ef82			 
ef82			;############################################################## 
ef82			; Write the null-terminated staring starting at the address in  
ef82			; HL to the console.   
ef82			; Clobbers: AF, C 
ef82			;############################################################## 
ef82			puts: 
ef82 e5				push	hl 
ef83 cd 88 ef			call	.puts_loop 
ef86 e1				pop	hl 
ef87 c9				ret 
ef88			 
ef88			.puts_loop: 
ef88 7e			        ld      a,(hl)                  ; get the next byte to send 
ef89 b7			        or      a 
ef8a 28 08		        jr      z,.puts_done             ; if A is zero, return 
ef8c 4f			        ld      c,a 
ef8d cd 77 ef		        call    con_tx_char 
ef90 23			        inc     hl                      ; point to next byte to write 
ef91 c3 88 ef		        jp      .puts_loop 
ef94			.puts_done: 
ef94 c9			        ret 
ef95			 
ef95			;############################################################## 
ef95			; Print a CRLF  
ef95			; Clobbers AF, C 
ef95			;############################################################## 
ef95			puts_crlf: 
ef95 cd 7b ef		        call    iputs 
ef98 ..			        defb    '\r\n\0' 
ef9b c9			        ret 
ef9c			 
ef9c			;########################################################################## 
ef9c			; General save areas 
ef9c			;########################################################################## 
ef9c			 
ef9c 00...		gpio_out_cache: ds  1			; GPIO output latch cache 
ef9d			 
ef9d			;########################################################################## 
ef9d			; The bios_disk_XXX values are used to retain the most recent values that 
ef9d			; have been set by the .bios_setXXX routines. 
ef9d			; These are used by the bios_read and bios_write routines. 
ef9d			;########################################################################## 
ef9d			bios_disk_dma:				; last set value of the DMA buffer address 
ef9d a5 a5			dw	0xa5a5 
ef9f			 
ef9f			bios_disk_track:			; last set value of the disk track 
ef9f a5 a5			dw	0xa5a5 
efa1			 
efa1			bios_disk_disk:				; last set value of the selected disk 
efa1 a5				db	0xa5 
efa2			 
efa2			bios_disk_sector:			; last set value of of the disk sector 
efa2 a5 a5			dw	0xa5a5 
efa4			 
efa4			;########################################################################## 
efa4			; Goal: Define a CP/M-compatible filesystem that can be implemented using 
efa4			; an SDHC card.  An SDHC card is comprised of a number of 512-byte blocks. 
efa4			; 
efa4			; Plan: 
efa4			; - Put 4 128-byte CP/M sectors into each 512-byte SDHC block. 
efa4			; - Treat each SDHC block as a CP/M track. 
efa4			; 
efa4			; This CP/M filesystem has: 
efa4			;  128 bytes/sector (CP/M requirement) 
efa4			;  4 sectors/track (Retro BIOS designer's choice) 
efa4			;  65536 total sectors (max CP/M limit) 
efa4			;  65536*128 = 8388608 gross bytes (max CP/M limit) 
efa4			;  65536/4 = 16384 tracks 
efa4			;  2048 allocation block size BLS (Retro BIOS designer's choice) 
efa4			;  8388608/2048 = 4096 gross allocation blocks in our filesystem 
efa4			;  32 = number of reserved tracks to hold the O/S 
efa4			;  32*512 = 16384 total reserved track bytes 
efa4			;  floor(4096-16384/2048) = 4088 total allocation blocks, absent the reserved tracks 
efa4			;  512 directory entries (Retro BIOS designer's choice) 
efa4			;  512*32 = 16384 total bytes in the directory 
efa4			;  ceiling(16384/2048) = 8 allocation blocks for the directory 
efa4			; 
efa4			;                  DSM<256   DSM>255 
efa4			;  BLS  BSH BLM    ------EXM-------- 
efa4			;  1024  3    7       0         x 
efa4			;  2048  4   15       1         0  <---------------------- 
efa4			;  4096  5   31       3         1 
efa4			;  8192  6   63       7         3 
efa4			; 16384  7  127      15         7 
efa4			; 
efa4			; ** NOTE: This filesystem design is inefficient because it is unlikely 
efa4			;          that ALL of the allocation blocks will ultimately get used! 
efa4			; 
efa4			;########################################################################## 
efa4			.bios_dph: 
efa4 00 00			dw	0		; XLT sector translation table (no xlation done) 
efa6 00 00			dw	0		; scratchpad 
efa8 00 00			dw	0		; scratchpad 
efaa 00 00			dw	0		; scratchpad 
efac b4 ef			dw	.bios_dirbuf	; DIRBUF pointer 
efae 34 f0			dw	.bios_dpb_a	; DPB pointer 
efb0 00 00			dw	0		; CSV pointer (optional, not implemented) 
efb2 43 f0			dw	.bios_alv_a	; ALV pointer 
efb4			 
efb4			.bios_dirbuf: 
efb4 00...			ds	128		; scratch directory buffer 
f034			.bios_wboot_stack:		; (ab)use the BDOS directory buffer as a stack during WBOOT 
f034			 
f034			.bios_dpb_a: 
f034 04 00			dw	4		; SPT 
f036 04				db	4		; BSH 
f037 0f				db	15		; BLM 
f038 00				db	0		; EXM 
f039 f7 0f			dw	4087		; DSM (max allocation block number) 
f03b ff 01			dw	511		; DRM 
f03d ff				db	0xff		; AL0 
f03e 00				db	0x00		; AL1 
f03f 00 00			dw	0		; CKS 
f041 20 00			dw	32		; OFF 
f043			 
f043			.bios_alv_a: 
f043 0xaa...			ds	(4087/8)+1,0xaa	; scratchpad used by BDOS for disk allocation info 
f242			.bios_alv_a_end: 
f242			 
f242			;########################################################################## 
f242			; Temporary stack used for BIOS calls needing more than a few stack levels. 
f242			; 
f242			; WARNING: This is expected to be in memory that is NOT bank-switchable! 
f242			;########################################################################## 
f242			.bios_stack_lo: 
f242 0x55...			ds	64,0x55		; 32 stack levels = 64 bytes (init to analyze) 
f282			bios_stack:			; full descending stack starts /after/ the storage area  
f282			 
f282			;########################################################################## 
f282			if $ < BOOT 
f282				ERROR THE BIOS WRAPPED AROUND PAST 0xffff 
f282			endif 
f282			 
f282			end 
# End of file -
f282
